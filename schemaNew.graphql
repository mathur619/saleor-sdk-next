# Anything
scalar _Any

union _Entity =
    Address
  | User
  | Group
  | ServiceAccount
  | App
  | ProductVariant
  | Product
  | ProductType
  | Collection
  | Category
  | ProductImage
type _Service {
  sdl: String
}

# Create a new address for the customer.
type AccountAddressCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A user instance for which the address was created.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

# Delete an address of the logged-in user.
type AccountAddressDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A user instance for which the address was deleted.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

# Updates an address of the logged-in user.
type AccountAddressUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A user object for which the address was edited.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

# Register a new user.
type AccountCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Informs whether users need to confirm their email address.
  requiresConfirmation: Boolean
  accountErrors: [AccountError!]!
  user: User
}

input AccountCreateInput {
  # The email address of the user.
  email: String!
  # Phone number of a user.
  phone: String!
  # Password.
  password: String!
  # Base of frontend URL that will be needed to create confirmation URL.
  redirectUrl: String
}

# Remove user account.
type AccountDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

type AccountError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: AccountErrorCode!
}

# An enumeration.
enum AccountErrorCode {
  ACTIVATE_OWN_ACCOUNT
  ACTIVATE_SUPERUSER_ACCOUNT
  DUPLICATED_INPUT_ITEM
  DEACTIVATE_OWN_ACCOUNT
  DEACTIVATE_SUPERUSER_ACCOUNT
  DELETE_NON_STAFF_USER
  DELETE_OWN_ACCOUNT
  DELETE_STAFF_ACCOUNT
  DELETE_SUPERUSER_ACCOUNT
  GRAPHQL_ERROR
  INVALID
  INVALID_PASSWORD
  LEFT_NOT_MANAGEABLE_PERMISSION
  INVALID_CREDENTIALS
  NOT_FOUND
  OUT_OF_SCOPE_SERVICE_ACCOUNT
  OUT_OF_SCOPE_USER
  OUT_OF_SCOPE_GROUP
  OUT_OF_SCOPE_PERMISSION
  PASSWORD_ENTIRELY_NUMERIC
  PASSWORD_TOO_COMMON
  PASSWORD_TOO_SHORT
  PASSWORD_TOO_SIMILAR
  REQUIRED
  UNIQUE
  JWT_SIGNATURE_EXPIRED
  JWT_INVALID_TOKEN
  JWT_DECODE_ERROR
  JWT_MISSING_TOKEN
  JWT_INVALID_CSRF_TOKEN
}

input AccountInput {
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # Billing address of the customer.
  defaultBillingAddress: AddressInput
  # Shipping address of the customer.
  defaultShippingAddress: AddressInput
}

# Register a new user.
type AccountRegister {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Informs whether users need to confirm their email address.
  requiresConfirmation: Boolean
  accountErrors: [AccountError!]!
  user: User
}

input AccountRegisterInput {
  # The email address of the user.
  email: String!
  # Password.
  password: String!
  # Base of frontend URL that will be needed to create confirmation URL.
  redirectUrl: String
}

input AccountRegisterInputV2 {
  # The email address of the user.
  email: String!
  # Phone number of a user.
  phone: String!
  # Password.
  password: String
}

# Register a new user with phone and email.
type AccountRegisterV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Informs whether users is new.
  isNewUser: Boolean
  # Informs whether users is active.
  isActiveUser: Boolean
  accountErrors: [AccountError!]!
  user: User
}

# Sends an email with the account removal link for the logged-in user.
type AccountRequestDeletion {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
}

# Sets a default address for the authenticated user.
type AccountSetDefaultAddress {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Updates the account of the logged-in user.
type AccountUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Updates metadata of the logged-in user.
type AccountUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Represents user address data.
type Address implements Node {
  # The ID of the object.
  id: ID!
  firstName: String!
  lastName: String!
  companyName: String!
  streetAddress1: String!
  streetAddress2: String!
  city: String!
  cityArea: String!
  postalCode: String!
  # Shop's default country.
  country: CountryDisplay!
  countryArea: String!
  phone: String
  # Address is user's default shipping address.
  isDefaultShippingAddress: Boolean
  # Address is user's default billing address.
  isDefaultBillingAddress: Boolean
}

# Creates user address.
type AddressCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A user instance for which the address was created.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

# Deletes an address.
type AddressDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A user instance for which the address was deleted.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

input AddressInput {
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # Company or organization.
  companyName: String
  # Address.
  streetAddress1: String
  # Address.
  streetAddress2: String
  # City.
  city: String
  # District.
  cityArea: String
  # Postal code.
  postalCode: String
  # Country.
  country: CountryCode
  # State or province.
  countryArea: String
  # Phone number.
  phone: String
}

type AddressLinkType implements Node {
  # The ID of the object.
  id: ID!
  type: AddressTypeType!
  address: Address!
  created: DateTime!
  updated: DateTime!
}

# Sets a default address for the given user.
type AddressSetDefault {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

# An enumeration.
enum AddressTypeEnum {
  BILLING
  SHIPPING
}

# An enumeration.
enum AddressTypes {
  HOME
  WORK
  OTHER
}

# An enumeration.
enum AddressTypeType {
  # HOME
  ADDRESSTYPES_HOME
  # WORK
  ADDRESSTYPES_WORK
  # OTHER
  ADDRESSTYPES_OTHER
}

# Updates an address.
type AddressUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A user object for which the address was edited.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

type AddressValidationData {
  countryCode: String
  countryName: String
  addressFormat: String
  addressLatinFormat: String
  allowedFields: [String]
  requiredFields: [String]
  upperFields: [String]
  countryAreaType: String
  countryAreaChoices: [ChoiceValue]
  cityType: String
  cityChoices: [ChoiceValue]
  cityAreaType: String
  cityAreaChoices: [ChoiceValue]
  postalCodeType: String
  postalCodeMatchers: [String]
  postalCodeExamples: [String]
  postalCodePrefix: String
}

# Represents allocation.
type Allocation implements Node {
  # The ID of the object.
  id: ID!
  # Quantity allocated for orders.
  quantity: Int!
  # The warehouse were items were allocated.
  warehouse: Warehouse!
}

# Represents app data.
type App implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  # Name of the app.
  name: String
  # The date and time when the app was created.
  created: DateTime
  # Determine if app will be set active or not.
  isActive: Boolean
  # List of the app's permissions.
  permissions: [Permission]
  # Last 4 characters of the tokens.
  tokens: [AppToken]
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # Type of the app.
  type: AppTypeEnum
  # List of webhooks assigned to this app.
  webhooks: [Webhook]
  # Description of this app.
  aboutApp: String
  # Description of the data privacy defined for this app.
  dataPrivacy: String
  # Url to details about the privacy policy on the app owner page.
  dataPrivacyUrl: String
  # Homepage of the app.
  homepageUrl: String
  # Support page for the app.
  supportUrl: String
  # Url to iframe with the configuration for the app.
  configurationUrl: String
  # Url to iframe with the app.
  appUrl: String
  # Version number of the app.
  version: String
  # JWT token used to authenticate by thridparty app.
  accessToken: String
}

# Activate the app.
type AppActivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  appErrors: [AppError!]!
  app: App
}

type AppCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [AppCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type AppCountableEdge {
  # The item at the end of the edge.
  node: App!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new app.
type AppCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The newly created authentication token.
  authToken: String
  appErrors: [AppError!]!
  app: App
}

# Deactivate the app.
type AppDeactivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  appErrors: [AppError!]!
  app: App
}

# Deletes an app.
type AppDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  appErrors: [AppError!]!
  app: App
}

# Delete failed installation.
type AppDeleteFailedInstallation {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  appErrors: [AppError!]!
  appInstallation: AppInstallation
}

type AppError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: AppErrorCode!
  # List of permissions which causes the error.
  permissions: [PermissionEnum!]
}

# An enumeration.
enum AppErrorCode {
  FORBIDDEN
  GRAPHQL_ERROR
  INVALID
  INVALID_STATUS
  INVALID_PERMISSION
  INVALID_URL_FORMAT
  INVALID_MANIFEST_FORMAT
  MANIFEST_URL_CANT_CONNECT
  NOT_FOUND
  REQUIRED
  UNIQUE
  OUT_OF_SCOPE_APP
  OUT_OF_SCOPE_PERMISSION
}

# Fetch and validate manifest.
type AppFetchManifest {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  manifest: Manifest
  appErrors: [AppError!]!
}

input AppFilterInput {
  search: String
  isActive: Boolean
  type: AppTypeEnum
}

input AppInput {
  # Name of the app.
  name: String
  # DEPRECATED: Use the `appActivate` and `appDeactivate` mutations instead. This field will be removed after 2020-07-31.
  isActive: Boolean
  # List of permission code names to assign to this app.
  permissions: [PermissionEnum]
}

# Install new app by using app manifest.
type AppInstall {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  appErrors: [AppError!]!
  appInstallation: AppInstallation
}

# Represents ongoing installation of app.
type AppInstallation implements Node & Job {
  appName: String!
  manifestUrl: String!
  # The ID of the object.
  id: ID!
  # Job status.
  status: JobStatusEnum!
  # Created date time of job in ISO 8601 format.
  createdAt: DateTime!
  # Date time of job last update in ISO 8601 format.
  updatedAt: DateTime!
  # Job message.
  message: String
}

input AppInstallInput {
  # Name of the app to install.
  appName: String
  # Url to app's manifest in JSON format.
  manifestUrl: String
  # Determine if app will be set active or not.
  activateAfterInstallation: Boolean = true
  # List of permission code names to assign to this app.
  permissions: [PermissionEnum]
}

# Retry failed installation of new app.
type AppRetryInstall {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  appErrors: [AppError!]!
  appInstallation: AppInstallation
}

enum AppSortField {
  # Sort apps by name.
  NAME
  # Sort apps by creation date.
  CREATION_DATE
}

input AppSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort apps by the selected field.
  field: AppSortField!
}

# Represents token data.
type AppToken implements Node {
  # Name of the authenticated token.
  name: String
  # Last 4 characters of the token.
  authToken: String
  # The ID of the object.
  id: ID!
}

# Creates a new token.
type AppTokenCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The newly created authentication token.
  authToken: String
  appErrors: [AppError!]!
  appToken: AppToken
}

# Deletes an authentication token assigned to app.
type AppTokenDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  appErrors: [AppError!]!
  appToken: AppToken
}

input AppTokenInput {
  # Name of the token.
  name: String
  # ID of app.
  app: ID!
}

# Verify provided app token.
type AppTokenVerify {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Determine if token is valid or not.
  valid: Boolean!
  appErrors: [AppError!]!
}

# An enumeration.
enum AppTypeEnum {
  LOCAL
  THIRDPARTY
}

# Updates an existing app.
type AppUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  appErrors: [AppError!]!
  app: App
}

# Assigns storefront's navigation menus.
type AssignNavigation {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Assigned navigation menu.
  menu: Menu
  menuErrors: [MenuError!]!
}

# Custom attribute of a product. Attributes can be assigned to products and variants at the product type level.
type Attribute implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  productTypes(
    before: String
    after: String
    first: Int
    last: Int
  ): ProductTypeCountableConnection!
  productVariantTypes(
    before: String
    after: String
    first: Int
    last: Int
  ): ProductTypeCountableConnection!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # The input type to use for entering attribute values in the dashboard.
  inputType: AttributeInputTypeEnum
  # Name of an attribute displayed in the interface.
  name: String
  # Internal representation of an attribute name.
  slug: String
  # List of attribute's values.
  values: [AttributeValue]
  # Whether the attribute requires values to be passed or not.
  valueRequired: Boolean!
  # Whether the attribute should be visible or not in storefront.
  visibleInStorefront: Boolean!
  # Whether the attribute can be filtered in storefront.
  filterableInStorefront: Boolean!
  # Whether the attribute can be filtered in dashboard.
  filterableInDashboard: Boolean!
  # Whether the attribute can be displayed in the admin product list.
  availableInGrid: Boolean!
  # Returns translated attribute fields for the given language code.
  translation(
    # A language code to return the translation for attribute.
    languageCode: LanguageCodeEnum!
  ): AttributeTranslation
  # The position of the attribute in the storefront navigation (0 by default).
  storefrontSearchPosition: Int!
}

# Assign attributes to a given product type.
type AttributeAssign {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The updated product type.
  productType: ProductType
  productErrors: [ProductError!]!
}

input AttributeAssignInput {
  # The ID of the attribute to assign.
  id: ID!
  # The attribute type to be assigned as.
  type: AttributeTypeEnum!
}

# Deletes attributes.
type AttributeBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Clears public metadata item for attribute.
type AttributeClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  attribute: Attribute
}

# Clears public metadata item for attribute.
type AttributeClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  attribute: Attribute
}

type AttributeCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [AttributeCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type AttributeCountableEdge {
  # The item at the end of the edge.
  node: Attribute!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates an attribute.
type AttributeCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  attribute: Attribute
  productErrors: [ProductError!]!
}

input AttributeCreateInput {
  # The input type to use for entering attribute values in the dashboard.
  inputType: AttributeInputTypeEnum
  # Name of an attribute displayed in the interface.
  name: String!
  # Internal representation of an attribute name.
  slug: String
  # List of attribute's values.
  values: [AttributeValueCreateInput]
  # Whether the attribute requires values to be passed or not.
  valueRequired: Boolean
  # Whether the attribute is for variants only.
  isVariantOnly: Boolean
  # Whether the attribute should be visible or not in storefront.
  visibleInStorefront: Boolean
  # Whether the attribute can be filtered in storefront.
  filterableInStorefront: Boolean
  # Whether the attribute can be filtered in dashboard.
  filterableInDashboard: Boolean
  # The position of the attribute in the storefront navigation (0 by default).
  storefrontSearchPosition: Int
  # Whether the attribute can be displayed in the admin product list.
  availableInGrid: Boolean
}

# Deletes an attribute.
type AttributeDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  attribute: Attribute
}

input AttributeFilterInput {
  valueRequired: Boolean
  isVariantOnly: Boolean
  visibleInStorefront: Boolean
  filterableInStorefront: Boolean
  filterableInDashboard: Boolean
  availableInGrid: Boolean
  search: String
  ids: [ID]
  inCollection: ID
  inCategory: ID
}

input AttributeInput {
  # Internal representation of an attribute name.
  slug: String!
  # [Deprecated] Internal representation of a value (unique per attribute). This field will be removed after 2020-07-31.
  value: String
  # Internal representation of a value (unique per attribute).
  values: [String]
}

# An enumeration.
enum AttributeInputTypeEnum {
  DROPDOWN
  MULTISELECT
}

# Reorder the values of an attribute.
type AttributeReorderValues {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Attribute from which values are reordered.
  attribute: Attribute
  productErrors: [ProductError!]!
}

enum AttributeSortField {
  # Sort attributes by name
  NAME
  # Sort attributes by slug
  SLUG
  # Sort attributes by the value required flag
  VALUE_REQUIRED
  # Sort attributes by the variant only flag
  IS_VARIANT_ONLY
  # Sort attributes by visibility in the storefront
  VISIBLE_IN_STOREFRONT
  # Sort attributes by the filterable in storefront flag
  FILTERABLE_IN_STOREFRONT
  # Sort attributes by the filterable in dashboard flag
  FILTERABLE_IN_DASHBOARD
  # Sort attributes by their position in storefront
  STOREFRONT_SEARCH_POSITION
  # Sort attributes based on whether they can be displayed or not in a product grid.
  AVAILABLE_IN_GRID
}

input AttributeSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort attributes by the selected field.
  field: AttributeSortField!
}

type AttributeTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Returns translated attribute fields for the given language code.
  translation(
    # A language code to return the translation for attribute.
    languageCode: LanguageCodeEnum!
  ): AttributeTranslation
  # Custom attribute of a product.
  attribute: Attribute
}

# Creates/Updates translations for attribute.
type AttributeTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  attribute: Attribute
}

type AttributeTranslation implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Translation language.
  language: LanguageDisplay!
}

enum AttributeTypeEnum {
  PRODUCT
  VARIANT
}

# Un-assign attributes from a given product type.
type AttributeUnassign {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The updated product type.
  productType: ProductType
  productErrors: [ProductError!]!
}

# Updates attribute.
type AttributeUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  attribute: Attribute
  productErrors: [ProductError!]!
}

input AttributeUpdateInput {
  # Name of an attribute displayed in the interface.
  name: String
  # Internal representation of an attribute name.
  slug: String
  # IDs of values to be removed from this attribute.
  removeValues: [ID]
  # New values to be created for this attribute.
  addValues: [AttributeValueCreateInput]
  # Whether the attribute requires values to be passed or not.
  valueRequired: Boolean
  # Whether the attribute is for variants only.
  isVariantOnly: Boolean
  # Whether the attribute should be visible or not in storefront.
  visibleInStorefront: Boolean
  # Whether the attribute can be filtered in storefront.
  filterableInStorefront: Boolean
  # Whether the attribute can be filtered in dashboard.
  filterableInDashboard: Boolean
  # The position of the attribute in the storefront navigation (0 by default).
  storefrontSearchPosition: Int
  # Whether the attribute can be displayed in the admin product list.
  availableInGrid: Boolean
}

# Update public metadata for attribute.
type AttributeUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  attribute: Attribute
}

# Update public metadata for attribute.
type AttributeUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  attribute: Attribute
}

# Represents a value of an attribute.
type AttributeValue implements Node {
  # The ID of the object.
  id: ID!
  # Name of a value displayed in the interface.
  name: String
  # Internal representation of a value (unique per attribute).
  slug: String
  # Type of value (used only when `value` field is set).
  type: AttributeValueType
    @deprecated(
      reason: "Use the `inputType` field to determine the type of attribute's value. This field will be removed after 2020-07-31."
    )
  # Returns translated attribute value fields for the given language code.
  translation(
    # A language code to return the translation for attribute value.
    languageCode: LanguageCodeEnum!
  ): AttributeValueTranslation
  # The input type to use for entering attribute values in the dashboard.
  inputType: AttributeInputTypeEnum
}

# Deletes values of attributes.
type AttributeValueBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Creates a value for an attribute.
type AttributeValueCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The updated attribute.
  attribute: Attribute
  productErrors: [ProductError!]!
  attributeValue: AttributeValue
}

input AttributeValueCreateInput {
  # Name of a value displayed in the interface.
  name: String!
}

# Deletes a value of an attribute.
type AttributeValueDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The updated attribute.
  attribute: Attribute
  productErrors: [ProductError!]!
  attributeValue: AttributeValue
}

input AttributeValueInput {
  # ID of the selected attribute.
  id: ID
  # The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created.
  values: [String]!
}

type AttributeValueTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Returns translated attribute value fields for the given language code.
  translation(
    # A language code to return the translation for attribute value.
    languageCode: LanguageCodeEnum!
  ): AttributeValueTranslation
  # Represents a value of an attribute.
  attributeValue: AttributeValue
}

# Creates/Updates translations for attribute value.
type AttributeValueTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  attributeValue: AttributeValue
}

type AttributeValueTranslation implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Translation language.
  language: LanguageDisplay!
}

enum AttributeValueType {
  COLOR
  GRADIENT
  URL
  STRING
}

# Updates value of an attribute.
type AttributeValueUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The updated attribute.
  attribute: Attribute
  productErrors: [ProductError!]!
  attributeValue: AttributeValue
}

type AuthorizationKey {
  # Name of the authorization backend.
  name: AuthorizationKeyType!
  # Authorization key (client ID).
  key: String!
}

# Adds an authorization key.
type AuthorizationKeyAdd {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Newly added authorization key.
  authorizationKey: AuthorizationKey
  # Updated shop.
  shop: Shop
  shopErrors: [ShopError!]!
}

# Deletes an authorization key.
type AuthorizationKeyDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Authorization key that was deleted.
  authorizationKey: AuthorizationKey
  # Updated shop.
  shop: Shop
  shopErrors: [ShopError!]!
}

input AuthorizationKeyInput {
  # Client authorization key (client ID).
  key: String!
  # Client secret.
  password: String!
}

# An enumeration.
enum AuthorizationKeyType {
  FACEBOOK
  GOOGLE_OAUTH2
}

type BannerError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: BannerErrorCodeEnum
}

# An enumeration.
enum BannerErrorCodeEnum {
  INVALID
}

input BannerInput {
  # Type of banner
  type: BannerTypes!
  # Link of the page to redirect when clicked
  link: String!
  # Is the banner visable
  isEnabled: Boolean
  # Position index of the banner, 1 will be shown first and so on
  position: Int!
  # Text content
  text: String!
  # Banner name
  name: String!
  # banner image for desktop screens.
  image: Upload
  # banner image for mobile screens
  imageMobile: Upload
  # Id of the related object
  relatedId: ID
}

# An enumeration.
enum BannerType {
  # HME
  BANNERTYPES_HOME_PAGE
  # HMS
  BANNERTYPES_HOME_PAGE_SECONDARY
  # CAT
  BANNERTYPES_CATEGORY
  # COL
  BANNERTYPES_COLLECTION
  # SLE
  BANNERTYPES_SALE
  # PDT
  BANNERTYPES_PRODUCT
}

# An enumeration.
enum BannerTypes {
  HOME_PAGE
  HOME_PAGE_SECONDARY
  CATEGORY
  COLLECTION
  SALE
  PRODUCT
}

# Creates Shipments for Bluedart.
type BluedartShipmentCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Combo to which products will be added.
  orders: Order
}

type BulkProductError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ProductErrorCode!
  # List of attributes IDs which causes the error.
  attributes: [ID!]
  # Index of an input list item that caused the error.
  index: Int
  # List of warehouse IDs which causes the error.
  warehouses: [ID!]
}

type BulkStockError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ProductErrorCode!
  # List of attributes IDs which causes the error.
  attributes: [ID!]
  # Index of an input list item that caused the error.
  index: Int
}

type CashbackType {
  amount: Decimal
  willAddOn: DateTime
}

input CashfreeCreateOrderInput {
  # Checkout ID.
  checkoutId: ID!
  # Url to redirect to after payment.
  returnUrl: String
}

type CashfreeOrderType {
  # Cashfree Order ID.
  token: String
  # Cashfree Payment url to use.
  paymentUrl: String
}

input CatalogueInput {
  # Products related to the discount.
  products: [ID]
  # Categories related to the discount.
  categories: [ID]
  # Collections related to the discount.
  collections: [ID]
}

# Represents a single category of products. Categories allow to organize products
# in a tree-hierarchies which can be used for navigation in the storefront.
type Category implements Node & ObjectWithMetadata {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  name: String!
  descriptionJson: JSONString!
  slug: String!
  parent: Category
  level: Int!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # List of ancestors of the category.
  ancestors(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CategoryCountableConnection
  # List of products in the category.
  products(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductCountableConnection
  # The storefront's URL for the category.
  url: String
    @deprecated(reason: "This field will be removed after 2020-07-31.")
  # Description of the category.
  description: String!
    @deprecated(reason: "Use the `descriptionJson` field instead.")
  # List of children of the category.
  children(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CategoryCountableConnection
  backgroundImage(
    # Size of the image.
    size: Int
  ): Image
  # Returns translated category fields for the given language code.
  translation(
    # A language code to return the translation for category.
    languageCode: LanguageCodeEnum!
  ): CategoryTranslation
}

# Deletes categories.
type CategoryBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Clears public metadata for category.
type CategoryClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  category: Category
}

# Clears private metadata for category.
type CategoryClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  category: Category
}

type CategoryCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [CategoryCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type CategoryCountableEdge {
  # The item at the end of the edge.
  node: Category!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new category.
type CategoryCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  category: Category
}

# Deletes a category.
type CategoryDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  category: Category
}

input CategoryFilterInput {
  search: String
  ids: [ID]
}

input CategoryInput {
  # Category description (HTML/text).
  description: String
  # Category description (JSON).
  descriptionJson: JSONString
  # Category name.
  name: String
  # Category slug.
  slug: String
  # Search engine optimization fields.
  seo: SeoInput
  # Background image file.
  backgroundImage: Upload
  # Alt text for an image.
  backgroundImageAlt: String
}

enum CategorySortField {
  # Sort categories by name.
  NAME
  # Sort categories by product count.
  PRODUCT_COUNT
  # Sort categories by subcategory count.
  SUBCATEGORY_COUNT
}

input CategorySortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort categories by the selected field.
  field: CategorySortField!
}

type CategoryTranslatableContent implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  name: String!
  descriptionJson: JSONString!
  # Description of the category.
  description: String!
    @deprecated(reason: "Use the `descriptionJson` field instead.")
  # Returns translated category fields for the given language code.
  translation(
    # A language code to return the translation for category.
    languageCode: LanguageCodeEnum!
  ): CategoryTranslation
  # Represents a single category of products.
  category: Category
}

# Creates/Updates translations for Category.
type CategoryTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  category: Category
}

type CategoryTranslation implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  name: String!
  descriptionJson: JSONString!
  # Translation language.
  language: LanguageDisplay!
  # Translated description of the category.
  description: String!
    @deprecated(reason: "Use the `descriptionJson` field instead.")
}

# Updates a category.
type CategoryUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  category: Category
}

# Update public metadata for category.
type CategoryUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  category: Category
}

# Update private metadata for category.
type CategoryUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  category: Category
}

# Checkout object.
type Checkout implements Node & ObjectWithMetadata {
  created: DateTime!
  lastChange: DateTime!
  user: User
  quantity: Int!
  billingAddress: Address
  shippingAddress: Address
  shippingMethod: ShippingMethod
  note: String!
  discount: Money
  discountName: String
  translatedDiscountName: String
  voucherCode: String
  # List of gift cards associated with this checkout.
  giftCards: [GiftCard]
  # The ID of the object.
  id: ID!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # Shipping methods that can be used with this order.
  availableShippingMethods: [ShippingMethod]!
  # List of available payment gateways.
  availablePaymentGateways: [PaymentGateway!]!
  # Email of a customer.
  email: String!
  # Returns True, if checkout requires shipping.
  isShippingRequired: Boolean!
  # A list of checkout lines, each containing information about an item in the checkout.
  lines: [CheckoutLine]
  # The price of the shipping, with all the taxes included.
  shippingPrice: TaxedMoney
  # The price of the checkout before shipping, with taxes included.
  subtotalPrice: TaxedMoney
  # The checkout's token.
  token: UUID!
  # The sum of the the checkout line prices, with all the taxes,shipping costs, and discounts included.
  totalPrice: TaxedMoney
}

# (Custom Implementation) Adds a gift card or a voucher to a checkout.
type CheckoutAddPromoCode {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The checkout with the added gift card or voucher.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# Create ShopifyUser.
type checkoutAddPromoCodeShopify {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The checkout with the added gift card or voucher.
  checkout: Checkout
}

# Update billing address in the existing checkout.
type CheckoutBillingAddressUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated checkout.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# Clear metadata for checkout.
type CheckoutClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  checkoutErrors: [CheckoutError!]!
  checkout: Checkout
}

# Clear private metadata for checkout.
type CheckoutClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  checkoutErrors: [CheckoutError!]!
  checkout: Checkout
}

# (Custom implementation) Completes the checkout. As a result a new order is
# created and a payment charge is made. This action requires a successful payment
# before it can be performed. In case additional confirmation step as 3D secure is
# required confirmationNeeded flag will be set to True and no order created until
# payment is confirmed with second call of this mutation.
type CheckoutComplete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Placed order.
  order: Order
  # Set to true if payment needs to be confirmed before checkout is complete.
  confirmationNeeded: Boolean!
  # Confirmation data used to process additional authorization steps.
  confirmationData: JSONString
  checkoutErrors: [CheckoutError!]!
}

type CheckoutCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [CheckoutCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type CheckoutCountableEdge {
  # The item at the end of the edge.
  node: Checkout!
  # A cursor for use in pagination.
  cursor: String!
}

# Create a new checkout.
type CheckoutCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Whether the checkout was created or the current active one was returned. Refer
  # to checkoutLinesAdd and checkoutLinesUpdate to merge a cart with an active checkout.
  created: Boolean
  checkoutErrors: [CheckoutError!]!
  checkout: Checkout
}

input CheckoutCreateInput {
  # A list of checkout lines, each containing information about an item in the checkout.
  lines: [CheckoutLineInput]!
  # The customer's email address.
  email: String
  # The mailing address to where the checkout will be shipped. Note: the address
  # will be ignored if the checkout doesn't contain shippable items.
  shippingAddress: AddressInput
  # Billing address of the customer.
  billingAddress: AddressInput
}

# Sets the customer as the owner of the checkout.
type CheckoutCustomerAttach {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated checkout.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# Removes the user assigned as the owner of the checkout.
type CheckoutCustomerDetach {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated checkout.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# Updates email address in the existing checkout object.
type CheckoutEmailUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated checkout.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

type CheckoutError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: CheckoutErrorCode!
  # List of varint IDs which causes the error.
  variants: [ID!]
}

# An enumeration.
enum CheckoutErrorCode {
  BILLING_ADDRESS_NOT_SET
  CHECKOUT_NOT_FULLY_PAID
  GRAPHQL_ERROR
  PRODUCT_NOT_PUBLISHED
  PRODUCT_UNAVAILABLE_FOR_PURCHASE
  INSUFFICIENT_STOCK
  INVALID
  INVALID_SHIPPING_METHOD
  NOT_FOUND
  PAYMENT_ERROR
  QUANTITY_GREATER_THAN_LIMIT
  REQUIRED
  SHIPPING_ADDRESS_NOT_SET
  SHIPPING_METHOD_NOT_APPLICABLE
  SHIPPING_METHOD_NOT_SET
  SHIPPING_NOT_REQUIRED
  TAX_ERROR
  UNIQUE
  VOUCHER_NOT_APPLICABLE
  ZERO_QUANTITY
}

# Represents an item in the checkout.
type CheckoutLine implements Node {
  # The ID of the object.
  id: ID!
  variant: ProductVariant!
  quantity: Int!
  # The sum of the checkout line price, taxes and discounts.
  totalPrice: TaxedMoney
  # Indicates whether the item need to be delivered.
  requiresShipping: Boolean
}

type CheckoutLineCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [CheckoutLineCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type CheckoutLineCountableEdge {
  # The item at the end of the edge.
  node: CheckoutLine!
  # A cursor for use in pagination.
  cursor: String!
}

# (Custom implementation) Deletes a CheckoutLine.
type CheckoutLineDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated checkout.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

input CheckoutLineInput {
  # The number of items purchased.
  quantity: Int!
  # ID of the product variant.
  variantId: ID!
}

# (Custom implementation) Adds a checkout line to the existing checkout.
type CheckoutLinesAdd {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated checkout.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# (Custom implementation) Updates checkout line in the existing checkout.
type CheckoutLinesUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated checkout.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# (Custom Implementation) Create a new payment via selected gateway for given checkout.
type CheckoutPaymentCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Related checkout object.
  checkout: Checkout
  # A newly created payment.
  payment: Payment
  paymentErrors: [PaymentError!]!
}

# (Custom Implementation) Remove a gift card or a voucher from a checkout.
type CheckoutRemovePromoCode {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The checkout with the removed gift card or voucher.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# Create ShopifyUser.
type checkoutRemovePromoCodeShopify {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The checkout with the added gift card or voucher.
  checkout: Checkout
}

# (Custom implementation) Update shipping address in the existing checkout.
type CheckoutShippingAddressUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated checkout.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# Updates the shipping address of the checkout.
type CheckoutShippingMethodUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated checkout.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# Checkout object.
type CheckoutType implements Node & ObjectWithMetadata {
  created: DateTime!
  lastChange: DateTime!
  user: User
  quantity: Int!
  billingAddress: Address
  shippingAddress: Address
  shippingMethod: ShippingMethod
  note: String!
  discount: Money
  discountName: String
  translatedDiscountName: String
  voucherCode: String
  # List of gift cards associated with this checkout.
  giftCards: [GiftCard]
  payments(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
  ): PaymentCountableConnection!
  # The ID of the object.
  id: ID!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # Shipping methods that can be used with this order.
  availableShippingMethods: [ShippingMethod]!
  # List of available payment gateways.
  availablePaymentGateways: [PaymentGateway!]!
  # Email of a customer.
  email: String!
  # Returns True, if checkout requires shipping.
  isShippingRequired: Boolean!
  # A list of checkout lines, each containing information about an item in the checkout.
  lines: [CheckoutLine]
  # The price of the shipping, with all the taxes included.
  shippingPrice: TaxedMoney
  # The price of the checkout before shipping, with taxes included.
  subtotalPrice: TaxedMoney
  # The checkout's token.
  token: UUID!
  # The sum of the the checkout line prices, with all the taxes,shipping costs, and discounts included.
  totalPrice: TaxedMoney
}

type CheckoutTypeCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [CheckoutTypeCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type CheckoutTypeCountableEdge {
  # The item at the end of the edge.
  node: CheckoutType!
  # A cursor for use in pagination.
  cursor: String!
}

# Updates metadata for checkout.
type CheckoutUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  checkoutErrors: [CheckoutError!]!
  checkout: Checkout
}

# Updates private metadata for checkout.
type CheckoutUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  checkoutErrors: [CheckoutError!]!
  checkout: Checkout
}

type ChoiceValue {
  raw: String
  verbose: String
}

# Represents a collection of products.
type Collection implements Node & ObjectWithMetadata {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  name: String!
  descriptionJson: JSONString!
  publicationDate: Date
  slug: String!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # List of products in this collection.
  products(
    # Filtering options for products.
    filter: ProductFilterInput
    # Sort products.
    sortBy: ProductOrder
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductCountableConnection
  backgroundImage(
    # Size of the image.
    size: Int
  ): Image
  # Description of the collection.
  description: String!
    @deprecated(reason: "Use the `descriptionJson` field instead.")
  # Returns translated collection fields for the given language code.
  translation(
    # A language code to return the translation for collection.
    languageCode: LanguageCodeEnum!
  ): CollectionTranslation
  # Whether the collection is published.
  isPublished: Boolean!
}

# Adds products to a collection.
type CollectionAddProducts {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Collection to which products will be added.
  collection: Collection
  productErrors: [ProductError!]!
}

# Deletes collections.
type CollectionBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Publish collections.
type CollectionBulkPublish {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Clears public metadata for collection.
type CollectionClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  collection: Collection
}

# Clears private metadata item for collection.
type CollectionClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  collection: Collection
}

type CollectionCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [CollectionCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type CollectionCountableEdge {
  # The item at the end of the edge.
  node: Collection!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new collection.
type CollectionCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  collection: Collection
}

input CollectionCreateInput {
  # Informs whether a collection is published.
  isPublished: Boolean
  # Name of the collection.
  name: String
  # Slug of the collection.
  slug: String
  # Description of the collection (HTML/text).
  description: String
  # Description of the collection (JSON).
  descriptionJson: JSONString
  # Background image file.
  backgroundImage: Upload
  # Alt text for an image.
  backgroundImageAlt: String
  # Search engine optimization fields.
  seo: SeoInput
  # Publication date. ISO 8601 standard.
  publicationDate: Date
  # List of products to be added to the collection.
  products: [ID]
}

# Deletes a collection.
type CollectionDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  collection: Collection
}

input CollectionFilterInput {
  published: CollectionPublished
  search: String
  ids: [ID]
}

input CollectionInput {
  # Informs whether a collection is published.
  isPublished: Boolean
  # Name of the collection.
  name: String
  # Slug of the collection.
  slug: String
  # Description of the collection (HTML/text).
  description: String
  # Description of the collection (JSON).
  descriptionJson: JSONString
  # Background image file.
  backgroundImage: Upload
  # Alt text for an image.
  backgroundImageAlt: String
  # Search engine optimization fields.
  seo: SeoInput
  # Publication date. ISO 8601 standard.
  publicationDate: Date
}

enum CollectionPublished {
  PUBLISHED
  HIDDEN
}

# Remove products from a collection.
type CollectionRemoveProducts {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Collection from which products will be removed.
  collection: Collection
  productErrors: [ProductError!]!
}

# Reorder the products of a collection.
type CollectionReorderProducts {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Collection from which products are reordered.
  collection: Collection
  productErrors: [ProductError!]!
}

enum CollectionSortField {
  # Sort collections by name.
  NAME
  # Sort collections by availability.
  AVAILABILITY
  # Sort collections by product count.
  PRODUCT_COUNT
  # Sort collections by publication date.
  PUBLICATION_DATE
}

input CollectionSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort collections by the selected field.
  field: CollectionSortField!
}

type CollectionTranslatableContent implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  name: String!
  descriptionJson: JSONString!
  # Description of the collection.
  description: String!
    @deprecated(reason: "Use the `descriptionJson` field instead.")
  # Returns translated collection fields for the given language code.
  translation(
    # A language code to return the translation for collection.
    languageCode: LanguageCodeEnum!
  ): CollectionTranslation
  # Represents a collection of products.
  collection: Collection
}

# Creates/Updates translations for collection.
type CollectionTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  collection: Collection
}

type CollectionTranslation implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  name: String!
  descriptionJson: JSONString!
  # Translation language.
  language: LanguageDisplay!
  # Translated description of the collection.
  description: String!
    @deprecated(reason: "Use the `descriptionJson` field instead.")
}

# Updates a collection.
type CollectionUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  collection: Collection
}

# Update public metadata for collection.
type CollectionUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  collection: Collection
}

# Update private metadata for collection.
type CollectionUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  collection: Collection
}

# Adds products to a combo.
type ComboAddProductVariants {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Combo to which products will be added.
  combo: ComboType
  productErrors: [ProductError!]!
}

# Creates a new combo.
type ComboCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  combo: ComboType
}

input ComboCreateInput {
  # Determines if combo is active.
  isPublished: Boolean
  # Publication date. ISO 8601 standard.
  publicationDate: Date
  # Combo Product which contains multiple product variants.
  variantId: ID!
  # List of product variants to be added to the combo.
  variants: [ID]
}

# Deletes a combo.
type ComboDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  combo: ComboType
}

# Adds products to a combo.
type ComboRemoveProductVariants {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Combo to which products will be added.
  combo: ComboType
  productErrors: [ProductError!]!
}

type ComboType implements Node {
  publicationDate: Date
  # The ID of the object.
  id: ID!
  isPublished: Boolean!
  variant: ProductVariant!
  variants(
    before: String
    after: String
    first: Int
    last: Int
  ): ProductVariantCountableConnection!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ComboTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [ComboTypeEdge]!
}

# A Relay edge containing a `ComboType` and its cursor.
type ComboTypeEdge {
  # The item at the end of the edge
  node: ComboType
  # A cursor for use in pagination
  cursor: String!
}

# Updates a combo.
type ComboUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  combo: ComboType
}

# Stores information about a single configuration field.
type ConfigurationItem {
  # Name of the field.
  name: String!
  # Current value of the field.
  value: String
  # Type of the field.
  type: ConfigurationTypeFieldEnum
  # Help text for the field.
  helpText: String
  # Label for the field.
  label: String
}

input ConfigurationItemInput {
  # Name of the field to update.
  name: String!
  # Value of the given field to update.
  value: String
}

# An enumeration.
enum ConfigurationTypeFieldEnum {
  STRING
  BOOLEAN
  SECRET
  PASSWORD
  SECRETMULTILINE
}

# Confirm user account with token sent by email during registration.
type ConfirmAccount {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An activated user account.
  user: User
  accountErrors: [AccountError!]!
}

# Confirm user account with otp sent by sms during registration.
type ConfirmAccountV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # JWT token, required to authenticate.
  token: String
  # JWT refresh token, required to re-generate access token.
  refreshToken: String
  # CSRF token required to re-generate access token.
  csrfToken: String
  # An activated user account.
  user: User
  accountErrors: [AccountError!]!
}

# Confirm the email change of the logged-in user.
type ConfirmEmailChange {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A user instance with a new email.
  user: User
  accountErrors: [AccountError!]!
}

# Create a new ContactUs entry.
type ContactUsCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A contactus instance.
  contactUs: ContactUsType
  contactUsErrors: [ContactUsError!]!
}

type ContactUsError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ContactUsErrorCode!
}

# An enumeration.
enum ContactUsErrorCode {
  PHONE_NUMBER_INVALID
}

input ContactUsInput {
  # Name of user.
  name: String!
  # Phone number of user.
  phone: String!
  # Email address of user.
  email: String!
  # Type of query.
  queryType: String!
  # Message given from user.
  message: String
}

input ContactUsOrder {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort Contact us by the selected field.
  field: ContactUsOrderField
}

enum ContactUsOrderField {
  NAME
  DATE
}

type ContactUsType implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  phone: String
  email: String!
  queryType: String!
  message: String
  createdAt: DateTime!
}

type ContactUsTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [ContactUsTypeEdge]!
}

# A Relay edge containing a `ContactUsType` and its cursor.
type ContactUsTypeEdge {
  # The item at the end of the edge
  node: ContactUsType
  # A cursor for use in pagination
  cursor: String!
}

# An enumeration.
enum CountryCode {
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BQ
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  CV
  KH
  CM
  CA
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CU
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  SZ
  ET
  EU
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  VA
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  KP
  MK
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  KR
  SS
  ES
  LK
  SD
  SR
  SJ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  UM
  US
  UY
  UZ
  VU
  VE
  VN
  VG
  VI
  WF
  EH
  YE
  ZM
  ZW
}

type CountryDisplay {
  # Country code.
  code: String!
  # Country name.
  country: String!
  # Country tax.
  vat: VAT
}

type CouponDiscountType implements Node {
  code: String
  discountAmount: Float
  # The ID of the object.
  id: ID!
}

type CouponDiscountTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [CouponDiscountTypeEdge]!
}

# A Relay edge containing a `CouponDiscountType` and its cursor.
type CouponDiscountTypeEdge {
  # The item at the end of the edge
  node: CouponDiscountType
  # A cursor for use in pagination
  cursor: String!
}

# Create a new banner
type CreateBanner {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A banner instance.
  banner: CustomBannerType
  bannerErrors: [BannerError!]!
}

# Creates an order on Cashfree.
type CreateCashfreeOrder {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Cashfree order object.
  cashfreeOrder: CashfreeOrderType
}

# Create a new header
type CreateHeader {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A header instance.
  header: HeaderType
}

# Create a new File that is going to be hosted.
type CreateHostingFile {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A hosting File instance.
  hosting: HostingType
}

# Create Influencer.
type CreateInfluencer {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An Influencer instance.
  influencer: InfluencerType
}

# Create a menu item image. This mutation must be sent as a `multipart` request.
# More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type CreateMenuItemsImages {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  menuItem: MenuItemV2
  image: MenuItemImageType
  imageMobile: MenuItemImageMobileType
  menuItemError: [MenuError!]!
}

input CreateMenuItemsImagesInput {
  # Represents an image file in a multipart request.
  image: Upload
  # Represents an image file in a multipart request.
  imageMobile: Upload
  # ID of a menu item
  menuItem: ID!
}

# Create Notification.
type CreateNotification {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Notification instance.
  notification: NotificationType
}

# Creates an order on Payu.
type CreatePayuOrder {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Payu order object.
  payuOrder: PayuOrderType
}

# Create Product.
type CreateProductCSV {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Product instance.
  product: Product
}

# Create a new product review.
type CreateProductReview {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A product review instance.
  productReview: ProductReviewType
}

# Create Product.
type CreateProductVariantCSV {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Product instance.
  productVariant: ProductVariant
}

# Creates an order on Razorpay.
type CreateRazorpayOrder {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Razorpay order object.
  razorpayOrder: RazorpayOrderType
  razorpayErrors: [RazorpayError!]!
}

# Create ShopifyUser.
type CreateShopifyUser {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An ShopifyUser instance.
  shopifyUser: ShopifyUserType
}

# Create JWT token.
type CreateToken {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # JWT token, required to authenticate.
  token: String
  # JWT refresh token, required to re-generate access token.
  refreshToken: String
  # CSRF token required to re-generate access token.
  csrfToken: String
  # A user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Create JWT token via OTP.
type CreateTokenOTP {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # JWT token, required to authenticate.
  token: String
  # JWT refresh token, required to re-generate access token.
  refreshToken: String
  # CSRF token required to re-generate access token.
  csrfToken: String
  # A user instance.
  user: User
  otpErrors: [OTPError!]!
}

# Create a new voucher rule.
type CreateVoucherRule {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A voucher rule instance.
  voucherRule: VoucherRuleType
  voucherErrors: [VoucherError!]!
}

# Create a new voucher rule link to add promo code.
type CreateVoucherRuleLink {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A voucher rule link instance.
  voucherRuleLink: VoucherRuleLinkType
  voucherErrors: [VoucherError!]!
}

type CreditCard {
  # Card brand.
  brand: String!
  # First 4 digits of the card number.
  firstDigits: String
  # Last 4 digits of the card number.
  lastDigits: String!
  # Two-digit number representing the cards expiration month.
  expMonth: Int
  # Four-digit number representing the cards expiration year.
  expYear: Int
}

type CustomBannerType implements Node {
  # The ID of the object.
  id: ID!
  text: String!
  type: BannerType!
  isEnabled: Boolean!
  position: Int!
  relatedId: String
  link: String!
  image: String
  imageMobile: String
  name: String!
  created: DateTime!
  updated: DateTime!
  # The URL of the image.
  imageUrl: String
  # The URL of the image for mobile screens.
  imageMobileUrl: String
}

type CustomBannerTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [CustomBannerTypeEdge]!
}

# A Relay edge containing a `CustomBannerType` and its cursor.
type CustomBannerTypeEdge {
  # The item at the end of the edge
  node: CustomBannerType
  # A cursor for use in pagination
  cursor: String!
}

# Deletes customers.
type CustomerBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  accountErrors: [AccountError!]!
}

# Creates a new customer.
type CustomerCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Deletes a customer.
type CustomerDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

# History log of the customer.
type CustomerEvent implements Node {
  # The ID of the object.
  id: ID!
  # Date when event happened at in ISO 8601 format.
  date: DateTime
  # Customer event type.
  type: CustomerEventsEnum
  # User who performed the action.
  user: User
  # Content of the event.
  message: String
  # Number of objects concerned by the event.
  count: Int
  # The concerned order.
  order: Order
  # The concerned order line.
  orderLine: OrderLine
}

# An enumeration.
enum CustomerEventsEnum {
  ACCOUNT_CREATED
  PASSWORD_RESET_LINK_SENT
  PASSWORD_RESET
  EMAIL_CHANGED_REQUEST
  PASSWORD_CHANGED
  EMAIL_CHANGED
  PLACED_ORDER
  NOTE_ADDED_TO_ORDER
  DIGITAL_LINK_DOWNLOADED
  CUSTOMER_DELETED
  NAME_ASSIGNED
  EMAIL_ASSIGNED
  NOTE_ADDED
}

input CustomerFilterInput {
  dateJoined: DateRangeInput
  moneySpent: PriceRangeInput
  numberOfOrders: IntRangeInput
  placedOrders: DateRangeInput
  search: String
}

input CustomerInput {
  # Billing address of the customer.
  defaultBillingAddress: AddressInput
  # Shipping address of the customer.
  defaultShippingAddress: AddressInput
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # The unique email address of the user.
  email: String
  # User account is active.
  isActive: Boolean
  # A note about the user.
  note: String
}

# Updates an existing customer.
type CustomerUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

type CustomOrderStatus {
  status: String
}

type CustomWalletLogType implements Node {
  # The ID of the object.
  id: ID!
  amount: Float!
  wallet: WalletType!
  expiry: Boolean!
  reason: String!
  type: WalletLogType!
  created: DateTime!
}

type CustomWalletLogTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [CustomWalletLogTypeEdge]!
}

# A Relay edge containing a `CustomWalletLogType` and its cursor.
type CustomWalletLogTypeEdge {
  # The item at the end of the edge
  node: CustomWalletLogType
  # A cursor for use in pagination
  cursor: String!
}

# The `Date` scalar type
 represents a Date
# value as specified by
# [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
scalar Date

input DateRangeInput {
  # Start date.
  gte: Date
  # End date.
  lte: Date
}

# The `DateTime` scalar type
 represents a DateTime
# value as specified by
# [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
scalar DateTime

input DateTimeRangeInput {
  # Start date.
  gte: DateTime
  # End date.
  lte: DateTime
}

# Deactivate all JWT tokens of the currently authenticated user.
type DeactivateAllUserTokens {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
}

# The `Decimal` scalar type
 represents a python Decimal.
scalar Decimal

# Delete a banner
type DeleteBanner {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  ok: Boolean
  bannerErrors: [BannerError!]!
}

# Delete bulk voucher rules.
type DeleteBulkVoucherRule {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  voucherErrors: [VoucherError!]!
}

# Delete a file that is hosted.
type DeleteHostingFile {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Is the operation successful.
  result: Boolean
}

# Delete an Influencer instance.
type DeleteInfluencer {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An Influencer instance.
  influencer: InfluencerType
  influencerErrors: [InfluencerError!]!
}

# Delete metadata of an object.
type DeleteMetadata {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadata
}

# Delete metadata of an object.
type DeleteMetadataV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadataV2
}

# Delete object's private metadata.
type DeletePrivateMetadata {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadata
}

# Delete object's private metadata.
type DeletePrivateMetadataV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadataV2
}

# Edit existing product review.
type DeleteProductReview {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A product review instance.
  productReview: ProductReviewType
}

# Delete an ShopifyUser instance.
type DeleteShopifyUser {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An ShopifyUser instance.
  shopifyUser: ShopifyUserType
  shopifyUserErrors: [ShopifyUserError!]!
}

# Delete a subscription.
type DeleteSubscription {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A subscription instance
  subscription: SubscriptionType
  subscriptionError: [SubscriptionError!]!
}

# Delete a voucher rule.
type DeleteVoucherRule {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  voucherErrors: [VoucherError!]!
  voucherRule: VoucherRuleType
}

type DeliverySchedulerType implements Node & ObjectWithMetadataV2 {
  # The ID of the object.
  id: ID!
  warehouse: String
  deliveryDate: Date
  deliveryTime: String
  availableSlots: Int!
  slotsFilled: Int!
  startTime: String
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItemV2]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItemV2]!
}

type DeliverySchedulerTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [DeliverySchedulerTypeEdge]!
}

# A Relay edge containing a `DeliverySchedulerType` and its cursor.
type DeliverySchedulerTypeEdge {
  # The item at the end of the edge
  node: DeliverySchedulerType
  # A cursor for use in pagination
  cursor: String!
}

type DigitalContent implements Node & ObjectWithMetadata {
  useDefaultSettings: Boolean!
  automaticFulfillment: Boolean!
  productVariant: ProductVariant!
  contentFile: String!
  maxDownloads: Int
  urlValidDays: Int
  # List of URLs for the digital variant.
  urls: [DigitalContentUrl]
  # The ID of the object.
  id: ID!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
}

type DigitalContentCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [DigitalContentCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type DigitalContentCountableEdge {
  # The item at the end of the edge.
  node: DigitalContent!
  # A cursor for use in pagination.
  cursor: String!
}

# Create new digital content. This mutation must be sent as a `multipart` request.
# More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type DigitalContentCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  variant: ProductVariant
  content: DigitalContent
  productErrors: [ProductError!]!
}

# Remove digital content assigned to given variant.
type DigitalContentDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  variant: ProductVariant
  productErrors: [ProductError!]!
}

input DigitalContentInput {
  # Use default digital content settings for this product.
  useDefaultSettings: Boolean!
  # Determines how many times a download link can be accessed by a customer.
  maxDownloads: Int
  # Determines for how many days a download link is active since it was generated.
  urlValidDays: Int
  # Overwrite default automatic_fulfillment setting for variant.
  automaticFulfillment: Boolean
}

# Update digital content.
type DigitalContentUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  variant: ProductVariant
  content: DigitalContent
  productErrors: [ProductError!]!
}

input DigitalContentUploadInput {
  # Use default digital content settings for this product.
  useDefaultSettings: Boolean!
  # Determines how many times a download link can be accessed by a customer.
  maxDownloads: Int
  # Determines for how many days a download link is active since it was generated.
  urlValidDays: Int
  # Overwrite default automatic_fulfillment setting for variant.
  automaticFulfillment: Boolean
  # Represents an file in a multipart request.
  contentFile: Upload!
}

type DigitalContentUrl implements Node {
  content: DigitalContent!
  created: DateTime!
  downloadNum: Int!
  # The ID of the object.
  id: ID!
  # URL for digital content.
  url: String
  # UUID of digital content.
  token: UUID!
}

# Generate new URL to digital content.
type DigitalContentUrlCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  digitalContentUrl: DigitalContentUrl
}

input DigitalContentUrlCreateInput {
  # Digital content ID which URL will belong to.
  content: ID!
}

type DiscountError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: DiscountErrorCode!
}

# An enumeration.
enum DiscountErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

enum DiscountStatusEnum {
  ACTIVE
  EXPIRED
  SCHEDULED
}

type DiscountsType {
  couponDiscount: Decimal
  prepaidDiscount: Decimal
  cashbackDiscount: Decimal
}

enum DiscountType {
  PERCENTAGE
  FIXED
}

enum DiscountValueTypeEnum {
  FIXED
  PERCENTAGE
}

# Represents shop's domain.
type Domain {
  # The host name of the domain.
  host: String!
  # Inform if SSL is enabled.
  sslEnabled: Boolean!
  # Shop's absolute URL.
  url: String!
}

# Deletes draft orders.
type DraftOrderBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  orderErrors: [OrderError!]!
}

# Completes creating an order.
type DraftOrderComplete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Completed order.
  order: Order
  orderErrors: [OrderError!]!
}

# Creates a new draft order.
type DraftOrderCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  orderErrors: [OrderError!]!
  order: Order
}

input DraftOrderCreateInput {
  # Billing address of the customer.
  billingAddress: AddressInput
  user: ID
  # Email address of the customer.
  userEmail: String
  # Discount amount for the order.
  discount: PositiveDecimal
  # Shipping address of the customer.
  shippingAddress: AddressInput
  # ID of a selected shipping method.
  shippingMethod: ID
  # ID of the voucher associated with the order.
  voucher: ID
  # A note from a customer. Visible by customers in the order summary.
  customerNote: String
  # Variant line input consisting of variant ID and quantity of products.
  lines: [OrderLineCreateInput]
}

# Deletes a draft order.
type DraftOrderDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  orderErrors: [OrderError!]!
  order: Order
}

input DraftOrderInput {
  # Billing address of the customer.
  billingAddress: AddressInput
  user: ID
  # Email address of the customer.
  userEmail: String
  # Discount amount for the order.
  discount: PositiveDecimal
  # Shipping address of the customer.
  shippingAddress: AddressInput
  # ID of a selected shipping method.
  shippingMethod: ID
  # ID of the voucher associated with the order.
  voucher: ID
  # A note from a customer. Visible by customers in the order summary.
  customerNote: String
}

# Deletes an order line from a draft order.
type DraftOrderLineDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A related draft order.
  order: Order
  # An order line that was deleted.
  orderLine: OrderLine
  orderErrors: [OrderError!]!
}

# Deletes order lines.
type DraftOrderLinesBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  orderErrors: [OrderError!]!
}

# Create order lines for a draft order.
type DraftOrderLinesCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A related draft order.
  order: Order
  # List of newly added order lines.
  orderLines: [OrderLine!]
  orderErrors: [OrderError!]!
}

# Updates an order line of a draft order.
type DraftOrderLineUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A related draft order.
  order: Order
  orderErrors: [OrderError!]!
  orderLine: OrderLine
}

# Updates a draft order.
type DraftOrderUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  orderErrors: [OrderError!]!
  order: Order
}

type DtcEligibleType implements Node {
  # The ID of the object.
  id: ID!
  # eligibilty of the given order numbers
  eligibility: JSONString
}

# Cancel a DTC Order
type DtcOrderCancel {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Response
  response: JSONString
}

# Return a DTC Order
type DtcOrderReturn {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Response
  response: JSONString
}

type DtcReturnProductType implements Node {
  # The ID of the object.
  id: ID!
  # return product of the given order numbers
  returnProduct: JSONString
}

type DtcTrackingType implements Node {
  # The ID of the object.
  id: ID!
  # trackings of an order
  trackings: JSONString
  # status trackings of an order
  statusData: JSONString
}

# Edit existing product review.
type EditProductReview {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A product review instance.
  productReview: ProductReviewType
}

type EmailValidatorType {
  # validity of email address
  isValid: Boolean!
}

# Represents an error in the input of a mutation.
type Error {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
}

type ExportError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ExportErrorCode!
}

# An enumeration.
enum ExportErrorCode {
  INVALID
  NOT_FOUND
  REQUIRED
}

# History log of export file.
type ExportEvent implements Node {
  # The ID of the object.
  id: ID!
  # Date when event happened at in ISO 8601 format.
  date: DateTime!
  # Export event type.
  type: ExportEventsEnum!
  # User who performed the action.
  user: User
  # App which performed the action.
  app: App
  # Content of the event.
  message: String!
}

# An enumeration.
enum ExportEventsEnum {
  EXPORT_PENDING
  EXPORT_SUCCESS
  EXPORT_FAILED
  EXPORT_DELETED
  EXPORTED_FILE_SENT
  EXPORT_FAILED_INFO_SENT
}

# Represents a job data of exported file.
type ExportFile implements Node & Job {
  # The ID of the object.
  id: ID!
  user: User
  app: App
  # Job status.
  status: JobStatusEnum!
  # Created date time of job in ISO 8601 format.
  createdAt: DateTime!
  # Date time of job last update in ISO 8601 format.
  updatedAt: DateTime!
  # Job message.
  message: String
  # The URL of field to download.
  url: String
  # List of events associated with the export.
  events: [ExportEvent!]
}

type ExportFileCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ExportFileCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ExportFileCountableEdge {
  # The item at the end of the edge.
  node: ExportFile!
  # A cursor for use in pagination.
  cursor: String!
}

input ExportFileFilterInput {
  createdAt: DateTimeRangeInput
  updatedAt: DateTimeRangeInput
  status: JobStatusEnum
  user: String
  app: String
}

enum ExportFileSortField {
  # Sort export file by status.
  STATUS
  # Sort export file by created at.
  CREATED_AT
  # Sort export file by updated at.
  UPDATED_AT
}

input ExportFileSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort export file by the selected field.
  field: ExportFileSortField!
}

input ExportInfoInput {
  # List of attribute ids witch should be exported.
  attributes: [ID!]
  # List of warehouse ids witch should be exported.
  warehouses: [ID!]
  # List of product fields witch should be exported.
  fields: [ProductFieldEnum!]
}

# Export products to csv file.
type ExportProducts {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The newly created export file job which is responsible for export data.
  exportFile: ExportFile
  exportErrors: [ExportError!]!
}

input ExportProductsInput {
  # Determine which products should be exported.
  scope: ExportScope!
  # Filtering options for products.
  filter: ProductFilterInput
  # List of products IDS to export.
  ids: [ID!]
  # Input with info about fields which should be exported.
  exportInfo: ExportInfoInput
  # Type of exported file.
  fileType: FileTypesEnum!
}

# Export products to csv file.
type ExportProductsV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The newly created export file job which is responsible for export data.
  exportFile: ExportFile
  exportErrors: [ExportError!]!
}

input ExportProductsV2InfoInput {
  # List of attribute ids witch should be exported.
  attributes: [ID!]
  # List of warehouse ids witch should be exported.
  warehouses: [ID!]
  # List of product fields witch should be exported.
  fields: [ProductFieldEnum!]
}

input ExportProductsV2Input {
  # Determine which products should be exported.
  scope: ExportScope!
  # Filtering options for products.
  filter: ProductFilterInput
  # List of products IDS to export.
  ids: [ID!]
  # Input with info about fields which should be exported.
  exportInfo: ExportProductsV2InfoInput
  # Type of exported file.
  fileType: FileTypesEnum!
}

enum ExportScope {
  # Export all products.
  ALL
  # Export products with given ids.
  IDS
  # Export the filtered products.
  FILTER
}

# An enumeration.
enum FileTypesEnum {
  CSV
  XLSX
}

# Represents order fulfillment.
type Fulfillment implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  fulfillmentOrder: Int!
  status: FulfillmentStatus!
  trackingNumber: String!
  created: DateTime!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # List of lines for the fulfillment.
  lines: [FulfillmentLine]
  # User-friendly fulfillment status.
  statusDisplay: String
  # Warehouse from fulfillment was fulfilled.
  warehouse: Warehouse
}

# Cancels existing fulfillment and optionally restocks items.
type FulfillmentCancel {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A canceled fulfillment.
  fulfillment: Fulfillment
  # Order which fulfillment was cancelled.
  order: Order
  orderErrors: [OrderError!]!
}

input FulfillmentCancelInput {
  # ID of warehouse where items will be restock.
  warehouseId: ID!
}

# Clears metadata for fulfillment.
type FulfillmentClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  fulfillment: Fulfillment
}

# Clears private metadata for fulfillment.
type FulfillmentClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  fulfillment: Fulfillment
}

# Represents line of the fulfillment.
type FulfillmentLine implements Node {
  # The ID of the object.
  id: ID!
  quantity: Int!
  orderLine: OrderLine
}

# An enumeration.
enum FulfillmentStatus {
  # Fulfilled
  FULFILLED
  # Canceled
  CANCELED
}

# Updates metadata for fulfillment.
type FulfillmentUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  fulfillment: Fulfillment
}

# Updates metadata for fulfillment.
type FulfillmentUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  fulfillment: Fulfillment
}

# Updates a fulfillment for an order.
type FulfillmentUpdateTracking {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A fulfillment with updated tracking.
  fulfillment: Fulfillment
  # Order for which fulfillment was updated.
  order: Order
  orderErrors: [OrderError!]!
}

input FulfillmentUpdateTrackingInput {
  # Fulfillment tracking number.
  trackingNumber: String
  # If true, send an email notification to the customer.
  notifyCustomer: Boolean = false
}

# Payment gateway client configuration key and value pair.
type GatewayConfigLine {
  # Gateway config key.
  field: String!
  # Gateway config value for key.
  value: String
}

# Create a new generic form entry.
type GenericFormCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A generic form instance.
  genericForm: GenericFormType
  genericFormErrors: [GenericFormError!]!
}

type GenericFormError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: GenericFormErrorCode!
}

# An enumeration.
enum GenericFormErrorCode {
  PHONE_NUMBER_INVALID
}

input GenericFormInput {
  # Name of user.
  name: String!
  # Phone number of user.
  phone: String!
  # Email address of user.
  email: String!
  # Response body.
  responseBody: String!
}

type GenericFormType implements Node {
  responseId: ID!
  responseBody: String
  name: String
  phone: String
  email: String
  createdAt: DateTime!
  # The ID of the object.
  id: ID!
}

# The `GenericScalar` scalar type
 represents a generic
# GraphQL scalar value
 that could be:
# String, Boolean, Int, Float, List or Object.
scalar GenericScalar

# Represents customers's geolocalization data.
type Geolocalization {
  # Country of the user acquired by his IP address.
  country: CountryDisplay
}

# A gift card is a prepaid electronic payment card accepted in stores. They can be
# used during checkout by providing a valid gift card codes.
type GiftCard implements Node {
  # Gift card code.
  code: String
  # The customer who bought a gift card.
  user: User
  created: DateTime!
  startDate: Date!
  endDate: Date
  lastUsedOn: DateTime
  isActive: Boolean!
  initialBalance: Money
  currentBalance: Money
  # The ID of the object.
  id: ID!
  # Code in format which allows displaying in a user interface.
  displayCode: String
}

# Activate a gift card.
type GiftCardActivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A gift card to activate.
  giftCard: GiftCard
  giftCardErrors: [GiftCardError!]!
}

type GiftCardCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [GiftCardCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type GiftCardCountableEdge {
  # The item at the end of the edge.
  node: GiftCard!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new gift card.
type GiftCardCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  giftCardErrors: [GiftCardError!]!
  giftCard: GiftCard
}

input GiftCardCreateInput {
  # Start date of the gift card in ISO 8601 format.
  startDate: Date
  # End date of the gift card in ISO 8601 format.
  endDate: Date
  # Value of the gift card.
  balance: PositiveDecimal
  # The customer's email of the gift card buyer.
  userEmail: String
  # Code to use the gift card.
  code: String
}

# Deactivate a gift card.
type GiftCardDeactivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A gift card to deactivate.
  giftCard: GiftCard
  giftCardErrors: [GiftCardError!]!
}

type GiftCardError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: GiftCardErrorCode!
}

# An enumeration.
enum GiftCardErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

# Update a gift card.
type GiftCardUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  giftCardErrors: [GiftCardError!]!
  giftCard: GiftCard
}

input GiftCardUpdateInput {
  # Start date of the gift card in ISO 8601 format.
  startDate: Date
  # End date of the gift card in ISO 8601 format.
  endDate: Date
  # Value of the gift card.
  balance: PositiveDecimal
  # The customer's email of the gift card buyer.
  userEmail: String
}

type GokwikType {
  # risk flag
  isHighRisk: Boolean!
  # if All the fields in checkout are present
  isDataValid: String!
}

# Represents permission group data.
type Group implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # List of group permissions
  permissions: [Permission]
  # List of group users
  users: [User]
  # True, if the currently authenticated user has rights to manage a group.
  userCanManage: Boolean!
}

type GroupCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [GroupCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type GroupCountableEdge {
  # The item at the end of the edge.
  node: Group!
  # A cursor for use in pagination.
  cursor: String!
}

input HeaderInput {
  # Text content
  text: String!
  # Header name
  name: String
}

type HeaderType implements Node {
  # The ID of the object.
  id: ID!
  text: String!
  name: String!
  created: DateTime!
}

type HeaderTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [HeaderTypeEdge]!
}

# A Relay edge containing a `HeaderType` and its cursor.
type HeaderTypeEdge {
  # The item at the end of the edge
  node: HeaderType
  # A cursor for use in pagination
  cursor: String!
}

# Updates homepage collection of the shop.
type HomepageCollectionUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated shop.
  shop: Shop
  shopErrors: [ShopError!]!
}

input HostingInput {
  # Hosted image on admin panel.
  image: Upload
  # File name
  name: String!
}

input HostingOrder {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort hosted files by the selected field.
  field: HostingOrderField
}

enum HostingOrderField {
  NAME
}

type HostingType implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  image: String
  # The URL of the image
  imageUrl: String
}

type HostingTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [HostingTypeEdge]!
}

# A Relay edge containing a `HostingType` and its cursor.
type HostingTypeEdge {
  # The item at the end of the edge
  node: HostingType
  # A cursor for use in pagination
  cursor: String!
}

# Represents an image.
type Image {
  # The URL of the image.
  url: String!
  # Alt text for an image.
  alt: String
}

type InfluencerError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: InfluencerErrorCode!
}

# An enumeration.
enum InfluencerErrorCode {
  INVALID
  REQUIRED
  NAME_REQUIRED
}

# Single Influencer Details.
input InfluencerInput {
  # Influencer Name
  name: String!
  # Influencer Phone No.
  phone: String
  # Influencer Email
  email: String!
  # Influencer related meta_data
  metadata: String
}

type InfluencerType implements Node {
  metadata: JSONString
  privateMetadata: JSONString
  # The ID of the object.
  id: ID!
  name: String!
  phone: String!
  email: String!
  couponCode: String!
}

type InfluencerTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [InfluencerTypeEdge]!
}

# A Relay edge containing a `InfluencerType` and its cursor.
type InfluencerTypeEdge {
  # The item at the end of the edge
  node: InfluencerType
  # A cursor for use in pagination
  cursor: String!
}

input IntRangeInput {
  # Value greater than or equal to.
  gte: Int
  # Value less than or equal to.
  lte: Int
}

# Represents an Invoice.
type Invoice implements ObjectWithMetadata & Job & Node {
  # The ID of the object.
  id: ID!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # Job status.
  status: JobStatusEnum!
  number: String
  externalUrl: String
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # Created date time of job in ISO 8601 format.
  createdAt: DateTime!
  # Date time of job last update in ISO 8601 format.
  updatedAt: DateTime!
  # Job message.
  message: String
  # URL to download an invoice.
  url: String
}

# Creates a ready to send invoice.
type InvoiceCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

input InvoiceCreateInput {
  # Invoice number.
  number: String!
  # URL of an invoice to download.
  url: String!
}

# Deletes an invoice.
type InvoiceDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

type InvoiceError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: InvoiceErrorCode!
}

# An enumeration.
enum InvoiceErrorCode {
  REQUIRED
  NOT_READY
  URL_NOT_SET
  EMAIL_NOT_SET
  NUMBER_NOT_SET
  NOT_FOUND
  INVALID_STATUS
}

# Request an invoice for the order using plugin.
type InvoiceRequest {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Order related to an invoice.
  order: Order
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

# Requests deletion of an invoice.
type InvoiceRequestDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

# Send an invoice by email.
type InvoiceSendEmail {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

# Updates an invoice.
type InvoiceUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

# Upload an invoice pdf.
type InvoiceUpload {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Public url of the uploaded file.
  url: String
}

interface Job {
  # Job status.
  status: JobStatusEnum!
  # Created date time of job in ISO 8601 format.
  createdAt: DateTime!
  # Date time of job last update in ISO 8601 format.
  updatedAt: DateTime!
  # Job message.
  message: String
}

# An enumeration.
enum JobStatusEnum {
  PENDING
  SUCCESS
  FAILED
  DELETED
}

# Allows use of a JSON String for input / output from the GraphQL schema.
#
# Use of this type is *not recommended* as you lose the benefits of having a defined, static
# schema (one of the key benefits of GraphQL).
scalar JSONString

# An enumeration.
enum LanguageCodeEnum {
  AR
  AZ
  BG
  BN
  CA
  CS
  DA
  DE
  EL
  EN
  ES
  ES_CO
  ET
  FA
  FI
  FR
  HI
  HU
  HY
  ID
  IS
  IT
  JA
  KA
  KM
  KO
  LT
  MN
  MY
  NB
  NL
  PL
  PT
  PT_BR
  RO
  RU
  SK
  SL
  SQ
  SR
  SV
  SW
  TA
  TH
  TR
  UK
  VI
  ZH_HANS
  ZH_HANT
}

type LanguageDisplay {
  # ISO 639 representation of the language name.
  code: LanguageCodeEnum!
  # Full name of the language.
  language: String!
}

# The manifest definition.
type Manifest {
  identifier: String!
  version: String!
  name: String!
  about: String
  permissions: [Permission]
  appUrl: String
  configurationUrl: String
  tokenTargetUrl: String
  dataPrivacy: String
  dataPrivacyUrl: String
  homepageUrl: String
  supportUrl: String
}

type Margin {
  start: Int
  stop: Int
}

# Represents a single menu - an object that is used to help navigate through the store.
type Menu implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  slug: String!
  items: [MenuItem]
}

# Deletes menus.
type MenuBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  menuErrors: [MenuError!]!
}

type MenuCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [MenuCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type MenuCountableEdge {
  # The item at the end of the edge.
  node: Menu!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new Menu.
type MenuCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  menuErrors: [MenuError!]!
  menu: Menu
}

input MenuCreateInput {
  # Name of the menu.
  name: String!
  # Slug of the menu. Will be generated if not provided.
  slug: String
  # List of menu items.
  items: [MenuItemInput]
}

# Deletes a menu.
type MenuDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  menuErrors: [MenuError!]!
  menu: Menu
}

type MenuError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: MenuErrorCode!
}

# An enumeration.
enum MenuErrorCode {
  CANNOT_ASSIGN_NODE
  GRAPHQL_ERROR
  INVALID
  INVALID_MENU_ITEM
  NO_MENU_ITEM_PROVIDED
  NOT_FOUND
  REQUIRED
  TOO_MANY_MENU_ITEMS
  UNIQUE
}

input MenuFilterInput {
  search: String
  slug: [String]
}

input MenuInput {
  # Name of the menu.
  name: String
  # Slug of the menu.
  slug: String
}

# Represents a single item of the related menu. Can store categories, collection or pages.
type MenuItem implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  menu: MenuV2!
  parent: MenuItemV2
  category: Category
  collection: Collection
  page: Page
  level: Int!
  children: [MenuItem]
  # URL to the menu item.
  url: String
  # Returns translated menu item fields for the given language code.
  translation(
    # A language code to return the translation for menu item.
    languageCode: LanguageCodeEnum!
  ): MenuItemTranslation
}

# Deletes menu items.
type MenuItemBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  menuErrors: [MenuError!]!
}

type MenuItemCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [MenuItemCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type MenuItemCountableEdge {
  # The item at the end of the edge.
  node: MenuItem!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new menu item.
type MenuItemCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  menuErrors: [MenuError!]!
  menuItem: MenuItem
}

input MenuItemCreateInput {
  # Name of the menu item.
  name: String!
  # URL of the pointed item.
  url: String
  # Category to which item points.
  category: ID
  # Collection to which item points.
  collection: ID
  # Page to which item points.
  page: ID
  # Menu to which item belongs.
  menu: ID!
  # ID of the parent menu. If empty, menu will be top level menu.
  parent: ID
}

# Deletes a menu item.
type MenuItemDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  menuErrors: [MenuError!]!
  menuItem: MenuItem
}

input MenuItemFilterInput {
  search: String
  menuSlug: [String]
}

type MenuItemImageMobileType implements Node {
  # The ID of the object.
  id: ID!
  menu: MenuItemV2!
  image: String!
  imageMobile: String!
  ppoi: String!
  # The URL of the image.
  url(
    # Size of the image.
    size: Int
  ): String!
}

type MenuItemImageType implements Node {
  # The ID of the object.
  id: ID!
  menu: MenuItemV2!
  image: String!
  imageMobile: String!
  ppoi: String!
  # The URL of the image.
  url(
    # Size of the image.
    size: Int
  ): String!
}

input MenuItemInput {
  # Name of the menu item.
  name: String
  # URL of the pointed item.
  url: String
  # Category to which item points.
  category: ID
  # Collection to which item points.
  collection: ID
  # Page to which item points.
  page: ID
}

# Moves items of menus.
type MenuItemMove {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Assigned menu to move within.
  menu: Menu
  menuErrors: [MenuError!]!
}

input MenuItemMoveInput {
  # The menu item ID to move.
  itemId: ID!
  # ID of the parent menu. If empty, menu will be top level menu.
  parentId: ID
  # The new relative sorting position of the item (from -inf to +inf). 1 moves the
  # item one position forward, -1 moves the item one position backward, 0 leaves
  # the item unchanged.
  sortOrder: Int
}

# Moves items of menus.
type MenuItemMoveV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Assigned menu to move within.
  menu: MenuV2
  menuErrors: [MenuError!]!
}

input MenuItemSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort menu items by the selected field.
  field: MenuItemsSortField!
}

enum MenuItemsSortField {
  # Sort menu items by name.
  NAME
}

type MenuItemTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Returns translated menu item fields for the given language code.
  translation(
    # A language code to return the translation for menu item.
    languageCode: LanguageCodeEnum!
  ): MenuItemTranslation
  # Represents a single item of the related menu. Can store categories, collection or pages.
  menuItem: MenuItem
}

# Creates/Updates translations for Menu Item.
type MenuItemTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  menuItem: MenuItem
}

type MenuItemTranslation implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Translation language.
  language: LanguageDisplay!
}

# Updates a menu item.
type MenuItemUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  menuErrors: [MenuError!]!
  menuItem: MenuItem
}

# Represents a single item of the related menu. Can store categories, collection or pages.
type MenuItemV2 implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  menu: MenuV2!
  parent: MenuItemV2
  category: Category
  collection: Collection
  page: Page
  level: Int!
  children: [MenuItemV2]
  # URL to the menu item.
  url: String
  # Returns translated menu item fields for the given language code.
  translation(
    # A language code to return the translation for menu item.
    languageCode: LanguageCodeEnum!
  ): MenuItemTranslation
  image(
    # Size of the image.
    size: Int
  ): Image
  imageMobile(
    # Size of the image.
    size: Int
  ): Image
}

type MenuItemV2CountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [MenuItemV2CountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type MenuItemV2CountableEdge {
  # The item at the end of the edge.
  node: MenuItemV2!
  # A cursor for use in pagination.
  cursor: String!
}

enum MenuSortField {
  # Sort menus by name.
  NAME
  # Sort menus by items count.
  ITEMS_COUNT
}

input MenuSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort menus by the selected field.
  field: MenuSortField!
}

# Updates a menu.
type MenuUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  menuErrors: [MenuError!]!
  menu: Menu
}

# Represents a single menu - an object that is used to help navigate through the store.
type MenuV2 implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  slug: String!
  items: [MenuItemV2]
}

type MenuV2CountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [MenuV2CountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type MenuV2CountableEdge {
  # The item at the end of the edge.
  node: MenuV2!
  # A cursor for use in pagination.
  cursor: String!
}

type MetaClientStore {
  # Metadata client's name.
  name: String!
  # Metadata stored for a client.
  metadata: [MetaItem]!
}

type MetadataError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: MetadataErrorCode!
}

# An enumeration.
enum MetadataErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
}

input MetadataInput {
  # Key of a metadata item.
  key: String!
  # Value of a metadata item.
  value: String!
}

input MetadataInputV2 {
  # Key of a metadata item.
  key: String!
  # Value of a metadata item.
  value: String!
}

type MetadataItem {
  # Key of a metadata item.
  key: String!
  # Value of a metadata item.
  value: String!
}

type MetadataItemV2 {
  # Key of a metadata item.
  key: String!
  # Value of a metadata item.
  value: String!
}

input MetaInput {
  # Name of metadata client group.
  namespace: String!
  # Metadata client's name.
  clientName: String!
  # Key for stored data.
  key: String!
  # Stored metadata value.
  value: String!
}

type MetaItem {
  # Key of a metadata item.
  key: String!
  # Value of a metadata item.
  value: String!
}

input MetaPath {
  # Name of metadata client group.
  namespace: String!
  # Metadata client's name.
  clientName: String!
  # Key for stored data.
  key: String!
}

type MetaStore {
  # Name of metadata client group.
  namespace: String!
  # List of clients that stored metadata in a group.
  clients: [MetaClientStore]!
}

# Represents amount of money in specific currency.
type Money {
  # Currency code.
  currency: String!
  # Amount of money.
  amount: Float!
  # Money formatted according to the current locale.
  localized: String!
    @deprecated(
      reason: "Price formatting according to the current locale should be handled by the frontend client. This field will be removed after 2020-07-31."
    )
}

# Represents a range of amounts of money.
type MoneyRange {
  # Lower bound of a price range.
  start: Money
  # Upper bound of a price range.
  stop: Money
}

input MoveProductInput {
  # The ID of the product to move.
  productId: ID!
  # The relative sorting position of the product (from -inf to +inf) starting from
  # the first given product's actual position.1 moves the item one position
  # forward, -1 moves the item one position backward, 0 leaves the item unchanged.
  sortOrder: Int
}

type Mutation {
  # Add product to the current user's wishlist.
  wishlistAddProduct(
    # The ID of the product.
    productId: ID!
  ): WishlistAddProductMutation
  # Remove product from the current user's wishlist.
  wishlistRemoveProduct(
    # The ID of the product.
    productId: ID!
  ): WishlistRemoveProductMutation
  # Add product variant to the current user's wishlist.
  wishlistAddVariant(
    # The ID of the product variant.
    variantId: ID!
  ): WishlistAddProductVariantMutation
  # Remove product variant from the current user's wishlist.
  wishlistRemoveVariant(
    # The ID of the product variant.
    variantId: ID!
  ): WishlistRemoveProductVariantMutation
  # Creates a new webhook subscription.
  webhookCreate(
    # Fields required to create a webhook.
    input: WebhookCreateInput!
  ): WebhookCreate
  # Deletes a webhook subscription.
  webhookDelete(
    # ID of a webhook to delete.
    id: ID!
  ): WebhookDelete
  # Updates a webhook subscription.
  webhookUpdate(
    # ID of a webhook to update.
    id: ID!
    # Fields required to update a webhook.
    input: WebhookUpdateInput!
  ): WebhookUpdate
  # Creates new warehouse.
  createWarehouse(
    # Fields required to create warehouse.
    input: WarehouseCreateInput!
  ): WarehouseCreate
  # Updates given warehouse.
  updateWarehouse(
    # ID of a warehouse to update.
    id: ID!
    # Fields required to update warehouse.
    input: WarehouseUpdateInput!
  ): WarehouseUpdate
  # Deletes selected warehouse.
  deleteWarehouse(
    # ID of a warehouse to delete.
    id: ID!
  ): WarehouseDelete
  # Add shipping zone to given warehouse.
  assignWarehouseShippingZone(
    # ID of a warehouse to update.
    id: ID!
    # List of shipping zone IDs.
    shippingZoneIds: [ID!]!
  ): WarehouseShippingZoneAssign
  # Remove shipping zone from given warehouse.
  unassignWarehouseShippingZone(
    # ID of a warehouse to update.
    id: ID!
    # List of shipping zone IDs.
    shippingZoneIds: [ID!]!
  ): WarehouseShippingZoneUnassign
  # Adds an authorization key.
  authorizationKeyAdd(
    # Fields required to create an authorization key.
    input: AuthorizationKeyInput!
    # Type of an authorization key to add.
    keyType: AuthorizationKeyType!
  ): AuthorizationKeyAdd
  # Deletes an authorization key.
  authorizationKeyDelete(
    # Type of a key to delete.
    keyType: AuthorizationKeyType!
  ): AuthorizationKeyDelete
  # Creates a new staff notification recipient.
  staffNotificationRecipientCreate(
    # Fields required to create a staff notification recipient.
    input: StaffNotificationRecipientInput!
  ): StaffNotificationRecipientCreate
  # Updates a staff notification recipient.
  staffNotificationRecipientUpdate(
    # ID of a staff notification recipient to update.
    id: ID!
    # Fields required to update a staff notification recipient.
    input: StaffNotificationRecipientInput!
  ): StaffNotificationRecipientUpdate
  # Delete staff notification recipient.
  staffNotificationRecipientDelete(
    # ID of a staff notification recipient to delete.
    id: ID!
  ): StaffNotificationRecipientDelete
  # Updates homepage collection of the shop.
  homepageCollectionUpdate(
    # Collection displayed on homepage.
    collection: ID
  ): HomepageCollectionUpdate
  # Updates site domain of the shop.
  shopDomainUpdate(
    # Fields required to update site.
    input: SiteDomainInput
  ): ShopDomainUpdate
  # Updates shop settings.
  shopSettingsUpdate(
    # Fields required to update shop settings.
    input: ShopSettingsInput!
  ): ShopSettingsUpdate
  # Fetch tax rates.
  shopFetchTaxRates: ShopFetchTaxRates
  # Creates/Updates translations for Shop Settings.
  shopSettingsTranslate(
    # Fields required to update shop settings translations.
    input: ShopSettingsTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): ShopSettingsTranslate
  # Update the shop's address. If the `null` value is passed, the currently selected address will be deleted.
  shopAddressUpdate(
    # Fields required to update shop address.
    input: AddressInput
  ): ShopAddressUpdate
  # Creates a new shipping price.
  shippingPriceCreate(
    # Fields required to create a shipping price.
    input: ShippingPriceInput!
  ): ShippingPriceCreate
  # Deletes a shipping price.
  shippingPriceDelete(
    # ID of a shipping price to delete.
    id: ID!
  ): ShippingPriceDelete
  # Deletes shipping prices.
  shippingPriceBulkDelete(
    # List of shipping price IDs to delete.
    ids: [ID]!
  ): ShippingPriceBulkDelete
  # Updates a new shipping price.
  shippingPriceUpdate(
    # ID of a shipping price to update.
    id: ID!
    # Fields required to update a shipping price.
    input: ShippingPriceInput!
  ): ShippingPriceUpdate
  # Creates/Updates translations for shipping method.
  shippingPriceTranslate(
    # Shipping method ID.
    id: ID!
    input: NameTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): ShippingPriceTranslate
  # Creates a new shipping zone.
  shippingZoneCreate(
    # Fields required to create a shipping zone.
    input: ShippingZoneCreateInput!
  ): ShippingZoneCreate
  # Deletes a shipping zone.
  shippingZoneDelete(
    # ID of a shipping zone to delete.
    id: ID!
  ): ShippingZoneDelete
  # Deletes shipping zones.
  shippingZoneBulkDelete(
    # List of shipping zone IDs to delete.
    ids: [ID]!
  ): ShippingZoneBulkDelete
  # Updates a new shipping zone.
  shippingZoneUpdate(
    # ID of a shipping zone to update.
    id: ID!
    # Fields required to update a shipping zone.
    input: ShippingZoneUpdateInput!
  ): ShippingZoneUpdate
  # Creates an attribute.
  attributeCreate(
    # Fields required to create an attribute.
    input: AttributeCreateInput!
  ): AttributeCreate
  # Deletes an attribute.
  attributeDelete(
    # ID of an attribute to delete.
    id: ID!
  ): AttributeDelete
  # Deletes attributes.
  attributeBulkDelete(
    # List of attribute IDs to delete.
    ids: [ID]!
  ): AttributeBulkDelete
  # Assign attributes to a given product type.
  attributeAssign(
    # The operations to perform.
    operations: [AttributeAssignInput]!
    # ID of the product type to assign the attributes into.
    productTypeId: ID!
  ): AttributeAssign
  # Un-assign attributes from a given product type.
  attributeUnassign(
    # The IDs of the attributes to assign.
    attributeIds: [ID]!
    # ID of the product type to assign the attributes into.
    productTypeId: ID!
  ): AttributeUnassign
  # Updates attribute.
  attributeUpdate(
    # ID of an attribute to update.
    id: ID!
    # Fields required to update an attribute.
    input: AttributeUpdateInput!
  ): AttributeUpdate
  # Creates/Updates translations for attribute.
  attributeTranslate(
    # Attribute ID.
    id: ID!
    input: NameTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): AttributeTranslate
  # Update public metadata for attribute.
  attributeUpdateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): AttributeUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears public metadata item for attribute.
  attributeClearMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): AttributeClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Update public metadata for attribute.
  attributeUpdatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): AttributeUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears public metadata item for attribute.
  attributeClearPrivateMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): AttributeClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Creates a value for an attribute.
  attributeValueCreate(
    # Attribute to which value will be assigned.
    attribute: ID!
    # Fields required to create an AttributeValue.
    input: AttributeValueCreateInput!
  ): AttributeValueCreate
  # Deletes a value of an attribute.
  attributeValueDelete(
    # ID of a value to delete.
    id: ID!
  ): AttributeValueDelete
  # Deletes values of attributes.
  attributeValueBulkDelete(
    # List of attribute value IDs to delete.
    ids: [ID]!
  ): AttributeValueBulkDelete
  # Updates value of an attribute.
  attributeValueUpdate(
    # ID of an AttributeValue to update.
    id: ID!
    # Fields required to update an AttributeValue.
    input: AttributeValueCreateInput!
  ): AttributeValueUpdate
  # Creates/Updates translations for attribute value.
  attributeValueTranslate(
    # Attribute Value ID.
    id: ID!
    input: NameTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): AttributeValueTranslate
  # Reorder the values of an attribute.
  attributeReorderValues(
    # ID of an attribute.
    attributeId: ID!
    # The list of reordering operations for given attribute values.
    moves: [ReorderInput]!
  ): AttributeReorderValues
  # Creates a new category.
  categoryCreate(
    # Fields required to create a category.
    input: CategoryInput!
    # ID of the parent category. If empty, category will be top level category.
    parent: ID
  ): CategoryCreate
  # Deletes a category.
  categoryDelete(
    # ID of a category to delete.
    id: ID!
  ): CategoryDelete
  # Deletes categories.
  categoryBulkDelete(
    # List of category IDs to delete.
    ids: [ID]!
  ): CategoryBulkDelete
  # Updates a category.
  categoryUpdate(
    # ID of a category to update.
    id: ID!
    # Fields required to update a category.
    input: CategoryInput!
  ): CategoryUpdate
  # Creates/Updates translations for Category.
  categoryTranslate(
    # Category ID.
    id: ID!
    input: TranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): CategoryTranslate
  # Update public metadata for category.
  categoryUpdateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): CategoryUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears public metadata for category.
  categoryClearMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): CategoryClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Update private metadata for category.
  categoryUpdatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): CategoryUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears private metadata for category.
  categoryClearPrivateMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): CategoryClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Adds products to a collection.
  collectionAddProducts(
    # ID of a collection.
    collectionId: ID!
    # List of product IDs.
    products: [ID]!
  ): CollectionAddProducts
  # Creates a new collection.
  collectionCreate(
    # Fields required to create a collection.
    input: CollectionCreateInput!
  ): CollectionCreate
  # Deletes a collection.
  collectionDelete(
    # ID of a collection to delete.
    id: ID!
  ): CollectionDelete
  # Reorder the products of a collection.
  collectionReorderProducts(
    # ID of a collection.
    collectionId: ID!
    # The collection products position operations.
    moves: [MoveProductInput]!
  ): CollectionReorderProducts
  # Deletes collections.
  collectionBulkDelete(
    # List of collection IDs to delete.
    ids: [ID]!
  ): CollectionBulkDelete
  # Publish collections.
  collectionBulkPublish(
    # List of collections IDs to (un)publish.
    ids: [ID]!
    # Determine if collections will be published or not.
    isPublished: Boolean!
  ): CollectionBulkPublish
  # Remove products from a collection.
  collectionRemoveProducts(
    # ID of a collection.
    collectionId: ID!
    # List of product IDs.
    products: [ID]!
  ): CollectionRemoveProducts
  # Updates a collection.
  collectionUpdate(
    # ID of a collection to update.
    id: ID!
    # Fields required to update a collection.
    input: CollectionInput!
  ): CollectionUpdate
  # Creates/Updates translations for collection.
  collectionTranslate(
    # Collection ID.
    id: ID!
    input: TranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): CollectionTranslate
  # Update public metadata for collection.
  collectionUpdateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): CollectionUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears public metadata for collection.
  collectionClearMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): CollectionClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Update private metadata for collection.
  collectionUpdatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): CollectionUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears private metadata item for collection.
  collectionClearPrivateMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): CollectionClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Creates a new product.
  productCreate(
    # Fields required to create a product.
    input: ProductCreateInput!
  ): ProductCreate
  # Deletes a product.
  productDelete(
    # ID of a product to delete.
    id: ID!
  ): ProductDelete
  # Deletes products.
  productBulkDelete(
    # List of product IDs to delete.
    ids: [ID]!
  ): ProductBulkDelete
  # Publish products.
  productBulkPublish(
    # List of products IDs to publish.
    ids: [ID]!
    # Determine if products will be published or not.
    isPublished: Boolean!
  ): ProductBulkPublish
  # Updates an existing product.
  productUpdate(
    # ID of a product to update.
    id: ID!
    # Fields required to update a product.
    input: ProductInput!
  ): ProductUpdate
  # Creates/Updates translations for Product.
  productTranslate(
    # Product ID.
    id: ID!
    input: TranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): ProductTranslate
  # Update public metadata for product.
  productUpdateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): ProductUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears public metadata item for product.
  productClearMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): ProductClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Update private metadata for product.
  productUpdatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): ProductUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears private metadata item for product.
  productClearPrivateMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): ProductClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Set product availability for purchase date.
  productSetAvailabilityForPurchase(
    # Determine if product should be available for purchase.
    isAvailable: Boolean!
    # Id of product that availability for purchase should be changed.
    productId: ID!
    # A start date from which a product will be available for purchase. When not
    # set and isAvailable is set to True, the current day is assumed.
    startDate: Date
  ): ProductSetAvailabilityForPurchase
  # Create a product image. This mutation must be sent as a `multipart` request.
  # More detailed specs of the upload format can be found here:
  # https://github.com/jaydenseric/graphql-multipart-request-spec
  productImageCreate(
    # Fields required to create a product image.
    input: ProductImageCreateInput!
  ): ProductImageCreate
  # Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook.
  productVariantReorder(
    # The list of variant reordering operations.
    moves: [ReorderInput]!
    # Id of product that variants order will be altered.
    productId: ID!
  ): ProductVariantReorder
  # Deletes a product image.
  productImageDelete(
    # ID of a product image to delete.
    id: ID!
  ): ProductImageDelete
  # Deletes product images.
  productImageBulkDelete(
    # List of product image IDs to delete.
    ids: [ID]!
  ): ProductImageBulkDelete
  # Changes ordering of the product image.
  productImageReorder(
    # IDs of a product images in the desired order.
    imagesIds: [ID]!
    # Id of product that images order will be altered.
    productId: ID!
  ): ProductImageReorder
  # Updates a product image.
  productImageUpdate(
    # ID of a product image to update.
    id: ID!
    # Fields required to update a product image.
    input: ProductImageUpdateInput!
  ): ProductImageUpdate
  # Creates a new product type.
  productTypeCreate(
    # Fields required to create a product type.
    input: ProductTypeInput!
  ): ProductTypeCreate
  # Deletes a product type.
  productTypeDelete(
    # ID of a product type to delete.
    id: ID!
  ): ProductTypeDelete
  # Deletes product types.
  productTypeBulkDelete(
    # List of product type IDs to delete.
    ids: [ID]!
  ): ProductTypeBulkDelete
  # Updates an existing product type.
  productTypeUpdate(
    # ID of a product type to update.
    id: ID!
    # Fields required to update a product type.
    input: ProductTypeInput!
  ): ProductTypeUpdate
  # Reorder the attributes of a product type.
  productTypeReorderAttributes(
    # The list of attribute reordering operations.
    moves: [ReorderInput]!
    # ID of a product type.
    productTypeId: ID!
    # The attribute type to reorder.
    type: AttributeTypeEnum!
  ): ProductTypeReorderAttributes
  # Update public metadata for product type.
  productTypeUpdateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): ProductTypeUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears public metadata for product type.
  productTypeClearMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): ProductTypeClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Update private metadata for product type.
  productTypeUpdatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): ProductTypeUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears private metadata for product type.
  productTypeClearPrivateMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): ProductTypeClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Create new digital content. This mutation must be sent as a `multipart`
  # request. More detailed specs of the upload format can be found here:
  # https://github.com/jaydenseric/graphql-multipart-request-spec
  digitalContentCreate(
    # Fields required to create a digital content.
    input: DigitalContentUploadInput!
    # ID of a product variant to upload digital content.
    variantId: ID!
  ): DigitalContentCreate
  # Remove digital content assigned to given variant.
  digitalContentDelete(
    # ID of a product variant with digital content to remove.
    variantId: ID!
  ): DigitalContentDelete
  # Update digital content.
  digitalContentUpdate(
    # Fields required to update a digital content.
    input: DigitalContentInput!
    # ID of a product variant with digital content to update.
    variantId: ID!
  ): DigitalContentUpdate
  # Generate new URL to digital content.
  digitalContentUrlCreate(
    # Fields required to create a new url.
    input: DigitalContentUrlCreateInput!
  ): DigitalContentUrlCreate
  # Creates a new variant for a product.
  productVariantCreate(
    # Fields required to create a product variant.
    input: ProductVariantCreateInput!
  ): ProductVariantCreate
  # Deletes a product variant.
  productVariantDelete(
    # ID of a product variant to delete.
    id: ID!
  ): ProductVariantDelete
  # Creates product variants for a given product.
  productVariantBulkCreate(
    # ID of the product to create the variants for.
    product: ID!
    # Input list of product variants to create.
    variants: [ProductVariantBulkCreateInput]!
  ): ProductVariantBulkCreate
  # Deletes product variants.
  productVariantBulkDelete(
    # List of product variant IDs to delete.
    ids: [ID]!
  ): ProductVariantBulkDelete
  # Creates stocks for product variant.
  productVariantStocksCreate(
    # Input list of stocks to create.
    stocks: [StockInput!]!
    # ID of a product variant for which stocks will be created.
    variantId: ID!
  ): ProductVariantStocksCreate
  # Delete stocks from product variant.
  productVariantStocksDelete(
    # ID of product variant for which stocks will be deleted.
    variantId: ID!
    warehouseIds: [ID!]
  ): ProductVariantStocksDelete
  # Update stocks for product variant.
  productVariantStocksUpdate(
    # Input list of stocks to create.
    stocks: [StockInput!]!
    # ID of a product variant for which stocks will be created.
    variantId: ID!
  ): ProductVariantStocksUpdate
  # Updates an existing variant for product.
  productVariantUpdate(
    # ID of a product variant to update.
    id: ID!
    # Fields required to update a product variant.
    input: ProductVariantInput!
  ): ProductVariantUpdate
  # Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook.
  productVariantSetDefault(
    # Id of a product that will have the default variant set.
    productId: ID!
    # Id of a variant that will be set as default.
    variantId: ID!
  ): ProductVariantSetDefault
  # Creates/Updates translations for Product Variant.
  productVariantTranslate(
    # Product Variant ID.
    id: ID!
    input: NameTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): ProductVariantTranslate
  # Update public metadata for product variant.
  productVariantUpdateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): ProductVariantUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears public metadata for product variant.
  productVariantClearMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): ProductVariantClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Update private metadata for product variant.
  productVariantUpdatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): ProductVariantUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears private metadata for product variant.
  productVariantClearPrivateMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): ProductVariantClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Assign an image to a product variant.
  variantImageAssign(
    # ID of a product image to assign to a variant.
    imageId: ID!
    # ID of a product variant.
    variantId: ID!
  ): VariantImageAssign
  # Unassign an image from a product variant.
  variantImageUnassign(
    # ID of a product image to unassign from a variant.
    imageId: ID!
    # ID of a product variant.
    variantId: ID!
  ): VariantImageUnassign
  # Captures the authorized payment amount.
  paymentCapture(
    # Transaction amount.
    amount: PositiveDecimal
    # Payment ID.
    paymentId: ID!
  ): PaymentCapture
  # Refunds the captured payment amount.
  paymentRefund(
    # Transaction amount.
    amount: PositiveDecimal
    # Payment ID.
    paymentId: ID!
  ): PaymentRefund
  # Voids the authorized payment.
  paymentVoid(
    # Payment ID.
    paymentId: ID!
  ): PaymentVoid
  # Initializes payment process when it is required by gateway.
  paymentInitialize(
    # A gateway name used to initialize the payment.
    gateway: String!
    # Client-side generated data required to initialize the payment.
    paymentData: JSONString
  ): PaymentInitialize
  # Creates a new page.
  pageCreate(
    # Fields required to create a page.
    input: PageInput!
  ): PageCreate
  # Deletes a page.
  pageDelete(
    # ID of a page to delete.
    id: ID!
  ): PageDelete
  # Deletes pages.
  pageBulkDelete(
    # List of page IDs to delete.
    ids: [ID]!
  ): PageBulkDelete
  # Publish pages.
  pageBulkPublish(
    # List of page IDs to (un)publish.
    ids: [ID]!
    # Determine if pages will be published or not.
    isPublished: Boolean!
  ): PageBulkPublish
  # Updates an existing page.
  pageUpdate(
    # ID of a page to update.
    id: ID!
    # Fields required to update a page.
    input: PageInput!
  ): PageUpdate
  # Creates/Updates translations for Page.
  pageTranslate(
    # Page ID.
    id: ID!
    input: PageTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): PageTranslate
  # Completes creating an order.
  draftOrderComplete(
    # ID of the order that will be completed.
    id: ID!
  ): DraftOrderComplete
  # Creates a new draft order.
  draftOrderCreate(
    # Fields required to create an order.
    input: DraftOrderCreateInput!
  ): DraftOrderCreate
  # Deletes a draft order.
  draftOrderDelete(
    # ID of a draft order to delete.
    id: ID!
  ): DraftOrderDelete
  # Deletes draft orders.
  draftOrderBulkDelete(
    # List of draft order IDs to delete.
    ids: [ID]!
  ): DraftOrderBulkDelete
  # Deletes order lines.
  draftOrderLinesBulkDelete(
    # List of order lines IDs to delete.
    ids: [ID]!
  ): DraftOrderLinesBulkDelete
  # Create order lines for a draft order.
  draftOrderLinesCreate(
    # ID of the draft order to add the lines to.
    id: ID!
    # Fields required to add order lines.
    input: [OrderLineCreateInput]!
  ): DraftOrderLinesCreate
  # Deletes an order line from a draft order.
  draftOrderLineDelete(
    # ID of the order line to delete.
    id: ID!
  ): DraftOrderLineDelete
  # Updates an order line of a draft order.
  draftOrderLineUpdate(
    # ID of the order line to update.
    id: ID!
    # Fields required to update an order line.
    input: OrderLineInput!
  ): DraftOrderLineUpdate
  # Updates a draft order.
  draftOrderUpdate(
    # ID of a draft order to update.
    id: ID!
    # Fields required to update an order.
    input: DraftOrderInput!
  ): DraftOrderUpdate
  # Adds note to the order.
  orderAddNote(
    # ID of the order to add a note for.
    order: ID!
    # Fields required to create a note for the order.
    input: OrderAddNoteInput!
  ): OrderAddNote
  # Cancel an order.
  orderCancel(
    # ID of the order to cancel.
    id: ID!
  ): OrderCancel
  # Capture an order.
  orderCapture(
    # Amount of money to capture.
    amount: PositiveDecimal!
    # ID of the order to capture.
    id: ID!
  ): OrderCapture
  # Clears stored private metadata value.
  orderClearPrivateMeta(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): OrderClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears stored metadata value.
  orderClearMeta(
    # Fields required to update new or stored metadata item.
    input: MetaPath!
    # Token of an object to clear.
    token: UUID!
  ): OrderClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Creates new fulfillments for an order.
  orderFulfill(
    # Fields required to create an fulfillment.
    input: OrderFulfillInput!
    # ID of the order to be fulfilled.
    order: ID
  ): OrderFulfill
  # Cancels existing fulfillment and optionally restocks items.
  orderFulfillmentCancel(
    # ID of an fulfillment to cancel.
    id: ID!
    # Fields required to cancel an fulfillment.
    input: FulfillmentCancelInput!
  ): FulfillmentCancel
  # Updates a fulfillment for an order.
  orderFulfillmentUpdateTracking(
    # ID of an fulfillment to update.
    id: ID!
    # Fields required to update an fulfillment.
    input: FulfillmentUpdateTrackingInput!
  ): FulfillmentUpdateTracking
  # Clears metadata for fulfillment.
  orderFulfillmentClearMeta(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): FulfillmentClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Clears private metadata for fulfillment.
  orderFulfillmentClearPrivateMeta(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): FulfillmentClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Updates metadata for fulfillment.
  orderFulfillmentUpdateMeta(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): FulfillmentUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Updates metadata for fulfillment.
  orderFulfillmentUpdatePrivateMeta(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): FulfillmentUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Mark order as manually paid.
  orderMarkAsPaid(
    # ID of the order to mark paid.
    id: ID!
  ): OrderMarkAsPaid
  # Refund an order.
  orderRefund(
    # Amount of money to refund.
    amount: PositiveDecimal!
    # ID of the order to refund.
    id: ID!
  ): OrderRefund
  # Updates an order.
  orderUpdate(
    # ID of an order to update.
    id: ID!
    # Fields required to update an order.
    input: OrderUpdateInput!
  ): OrderUpdate
  # Updates meta for order.
  orderUpdateMeta(
    # Fields required to update new or stored metadata item.
    input: MetaInput!
    # Token of an object to update.
    token: UUID!
  ): OrderUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Updates private meta for order.
  orderUpdatePrivateMeta(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): OrderUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31."
    )
  # Updates a shipping method of the order.
  orderUpdateShipping(
    # ID of the order to update a shipping method.
    order: ID!
    # Fields required to change shipping method of the order.
    input: OrderUpdateShippingInput
  ): OrderUpdateShipping
  # Void an order.
  orderVoid(
    # ID of the order to void.
    id: ID!
  ): OrderVoid
  # Cancels orders.
  orderBulkCancel(
    # List of orders IDs to cancel.
    ids: [ID]!
  ): OrderBulkCancel
  # Delete metadata of an object.
  deleteMetadata(
    # ID of an object to update.
    id: ID!
    # Metadata keys to delete.
    keys: [String!]!
  ): DeleteMetadata
  # Delete object's private metadata.
  deletePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Metadata keys to delete.
    keys: [String!]!
  ): DeletePrivateMetadata
  # Updates metadata of an object.
  updateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update the object's metadata.
    input: [MetadataInput!]!
  ): UpdateMetadata
  # Updates private metadata of an object.
  updatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update the object's metadata.
    input: [MetadataInput!]!
  ): UpdatePrivateMetadata
  # Assigns storefront's navigation menus.
  assignNavigation(
    # ID of the menu.
    menu: ID
    # Type of the navigation bar to assign the menu to.
    navigationType: NavigationType!
  ): AssignNavigation
  # Creates a new Menu.
  menuCreate(
    # Fields required to create a menu.
    input: MenuCreateInput!
  ): MenuCreate
  # Deletes a menu.
  menuDelete(
    # ID of a menu to delete.
    id: ID!
  ): MenuDelete
  # Deletes menus.
  menuBulkDelete(
    # List of menu IDs to delete.
    ids: [ID]!
  ): MenuBulkDelete
  # Updates a menu.
  menuUpdate(
    # ID of a menu to update.
    id: ID!
    # Fields required to update a menu.
    input: MenuInput!
  ): MenuUpdate
  # Creates a new menu item.
  menuItemCreate(
    # Fields required to update a menu item. Only one of `url`, `category`, `page`, `collection` is allowed per item.
    input: MenuItemCreateInput!
  ): MenuItemCreate
  # Deletes a menu item.
  menuItemDelete(
    # ID of a menu item to delete.
    id: ID!
  ): MenuItemDelete
  # Deletes menu items.
  menuItemBulkDelete(
    # List of menu item IDs to delete.
    ids: [ID]!
  ): MenuItemBulkDelete
  # Updates a menu item.
  menuItemUpdate(
    # ID of a menu item to update.
    id: ID!
    # Fields required to update a menu item. Only one of `url`, `category`, `page`, `collection` is allowed per item.
    input: MenuItemInput!
  ): MenuItemUpdate
  # Creates/Updates translations for Menu Item.
  menuItemTranslate(
    # Menu Item ID.
    id: ID!
    input: NameTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): MenuItemTranslate
  # Moves items of menus.
  menuItemMove(
    # ID of the menu.
    menu: ID!
    # The menu position data.
    moves: [MenuItemMoveInput]!
  ): MenuItemMove
  # Request an invoice for the order using plugin.
  invoiceRequest(
    # Invoice number, if not provided it will be generated.
    number: String
    # ID of the order related to invoice.
    orderId: ID!
  ): InvoiceRequest
  # Requests deletion of an invoice.
  invoiceRequestDelete(
    # ID of an invoice to request the deletion.
    id: ID!
  ): InvoiceRequestDelete
  # Creates a ready to send invoice.
  invoiceCreate(
    # Fields required when creating an invoice.
    input: InvoiceCreateInput!
    # ID of the order related to invoice.
    orderId: ID!
  ): InvoiceCreate
  # Deletes an invoice.
  invoiceDelete(
    # ID of an invoice to delete.
    id: ID!
  ): InvoiceDelete
  # Updates an invoice.
  invoiceUpdate(
    # ID of an invoice to update.
    id: ID!
    # Fields to use when updating an invoice.
    input: UpdateInvoiceInput!
  ): InvoiceUpdate
  # Send an invoice by email.
  invoiceSendEmail(
    # ID of an invoice to be sent.
    id: ID!
  ): InvoiceSendEmail
  # Activate a gift card.
  giftCardActivate(
    # ID of a gift card to activate.
    id: ID!
  ): GiftCardActivate
  # Creates a new gift card.
  giftCardCreate(
    # Fields required to create a gift card.
    input: GiftCardCreateInput!
  ): GiftCardCreate
  # Deactivate a gift card.
  giftCardDeactivate(
    # ID of a gift card to deactivate.
    id: ID!
  ): GiftCardDeactivate
  # Update a gift card.
  giftCardUpdate(
    # ID of a gift card to update.
    id: ID!
    # Fields required to update a gift card.
    input: GiftCardUpdateInput!
  ): GiftCardUpdate
  # Update plugin configuration.
  pluginUpdate(
    # ID of plugin to update.
    id: ID!
    # Fields required to update a plugin configuration.
    input: PluginUpdateInput!
  ): PluginUpdate
  # Creates a new sale.
  saleCreate(
    # Fields required to create a sale.
    input: SaleInput!
  ): SaleCreate
  # Deletes a sale.
  saleDelete(
    # ID of a sale to delete.
    id: ID!
  ): SaleDelete
  # Deletes sales.
  saleBulkDelete(
    # List of sale IDs to delete.
    ids: [ID]!
  ): SaleBulkDelete
  # Updates a sale.
  saleUpdate(
    # ID of a sale to update.
    id: ID!
    # Fields required to update a sale.
    input: SaleInput!
  ): SaleUpdate
  # Adds products, categories, collections to a voucher.
  saleCataloguesAdd(
    # ID of a sale.
    id: ID!
    # Fields required to modify catalogue IDs of sale.
    input: CatalogueInput!
  ): SaleAddCatalogues
  # Removes products, categories, collections from a sale.
  saleCataloguesRemove(
    # ID of a sale.
    id: ID!
    # Fields required to modify catalogue IDs of sale.
    input: CatalogueInput!
  ): SaleRemoveCatalogues
  # Creates/updates translations for a sale.
  saleTranslate(
    # Voucher ID.
    id: ID!
    input: NameTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): SaleTranslate
  # Creates a new voucher.
  voucherCreate(
    # Fields required to create a voucher.
    input: VoucherInput!
  ): VoucherCreate
  # Deletes a voucher.
  voucherDelete(
    # ID of a voucher to delete.
    id: ID!
  ): VoucherDelete
  # Deletes vouchers.
  voucherBulkDelete(
    # List of voucher IDs to delete.
    ids: [ID]!
  ): VoucherBulkDelete
  # Updates a voucher.
  voucherUpdate(
    # ID of a voucher to update.
    id: ID!
    # Fields required to update a voucher.
    input: VoucherInput!
  ): VoucherUpdate
  # Adds products, categories, collections to a voucher.
  voucherCataloguesAdd(
    # ID of a voucher.
    id: ID!
    # Fields required to modify catalogue IDs of voucher.
    input: CatalogueInput!
  ): VoucherAddCatalogues
  # Removes products, categories, collections from a voucher.
  voucherCataloguesRemove(
    # ID of a voucher.
    id: ID!
    # Fields required to modify catalogue IDs of voucher.
    input: CatalogueInput!
  ): VoucherRemoveCatalogues
  # Creates/Updates translations for Voucher.
  voucherTranslate(
    # Voucher ID.
    id: ID!
    input: NameTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): VoucherTranslate
  # Export products to csv file.
  exportProducts(
    # Fields required to export product data
    input: ExportProductsInput!
  ): ExportProducts
  # (Custom Implementation) Adds a gift card or a voucher to a checkout.
  checkoutAddPromoCode(
    # Checkout ID.
    checkoutId: ID!
    # Gift card code or voucher code.
    promoCode: String!
  ): CheckoutAddPromoCode
  # Update billing address in the existing checkout.
  checkoutBillingAddressUpdate(
    # The billing address of the checkout.
    billingAddress: AddressInput!
    # ID of the checkout.
    checkoutId: ID!
  ): CheckoutBillingAddressUpdate
  # (Custom implementation) Completes the checkout. As a result a new order is
  # created and a payment charge is made. This action requires a successful
  # payment before it can be performed. In case additional confirmation step as 3D
  # secure is required confirmationNeeded flag will be set to True and no order
  # created until payment is confirmed with second call of this mutation.
  checkoutComplete(
    # Checkout ID.
    checkoutId: ID!
    # Client-side generated data required to finalize the payment.
    paymentData: JSONString
    # URL of a view where users should be redirected to see the order details. URL in RFC 1808 format.
    redirectUrl: String
    # Determines whether to store the payment source for future usage.
    storeSource: Boolean = false
  ): CheckoutComplete
  # Create a new checkout.
  checkoutCreate(
    # Fields required to create checkout.
    input: CheckoutCreateInput!
  ): CheckoutCreate
  # Sets the customer as the owner of the checkout.
  checkoutCustomerAttach(
    # ID of the checkout.
    checkoutId: ID!
    # [Deprecated] The ID of the customer. To identify a customer you should
    # authenticate with JWT. This field will be removed after 2020-07-31.
    customerId: ID
  ): CheckoutCustomerAttach
  # Removes the user assigned as the owner of the checkout.
  checkoutCustomerDetach(
    # Checkout ID.
    checkoutId: ID!
  ): CheckoutCustomerDetach
  # Updates email address in the existing checkout object.
  checkoutEmailUpdate(
    # Checkout ID.
    checkoutId: ID
    # email.
    email: String!
  ): CheckoutEmailUpdate
  # (Custom implementation) Deletes a CheckoutLine.
  checkoutLineDelete(
    # The ID of the checkout.
    checkoutId: ID!
    # ID of the checkout line to delete.
    lineId: ID
  ): CheckoutLineDelete
  # (Custom implementation) Adds a checkout line to the existing checkout.
  checkoutLinesAdd(
    # The ID of the checkout.
    checkoutId: ID!
    # A list of checkout lines, each containing information about an item in the checkout.
    lines: [CheckoutLineInput]!
  ): CheckoutLinesAdd
  # (Custom implementation) Updates checkout line in the existing checkout.
  checkoutLinesUpdate(
    # The ID of the checkout.
    checkoutId: ID!
    # A list of checkout lines, each containing information about an item in the checkout.
    lines: [CheckoutLineInput]!
  ): CheckoutLinesUpdate
  # (Custom Implementation) Remove a gift card or a voucher from a checkout.
  checkoutRemovePromoCode(
    # Checkout ID.
    checkoutId: ID!
    # Gift card code or voucher code.
    promoCode: String!
  ): CheckoutRemovePromoCode
  # (Custom Implementation) Create a new payment via selected gateway for given checkout.
  checkoutPaymentCreate(
    # Checkout ID.
    checkoutId: ID!
    # Data required to create a new payment.
    input: PaymentInput!
  ): CheckoutPaymentCreate
  # (Custom implementation) Update shipping address in the existing checkout.
  checkoutShippingAddressUpdate(
    # ID of the checkout.
    checkoutId: ID!
    # The mailing address to where the checkout will be shipped.
    shippingAddress: AddressInput!
  ): CheckoutShippingAddressUpdate
  # Updates the shipping address of the checkout.
  checkoutShippingMethodUpdate(
    # Checkout ID.
    checkoutId: ID
    # Shipping method.
    shippingMethodId: ID!
  ): CheckoutShippingMethodUpdate
  # Updates metadata for checkout.
  checkoutUpdateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): CheckoutUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation. This field will be removed after 2020-07-31."
    )
  # Clear metadata for checkout.
  checkoutClearMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): CheckoutClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation. This field will be removed after 2020-07-31."
    )
  # Updates private metadata for checkout.
  checkoutUpdatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): CheckoutUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation. This field will be removed after 2020-07-31."
    )
  # Clear private metadata for checkout.
  checkoutClearPrivateMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): CheckoutClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation. This field will be removed after 2020-07-31."
    )
  # Creates a new app.
  appCreate(
    # Fields required to create a new app.
    input: AppInput!
  ): AppCreate
  # Updates an existing app.
  appUpdate(
    # ID of an app to update.
    id: ID!
    # Fields required to update an existing app.
    input: AppInput!
  ): AppUpdate
  # Deletes an app.
  appDelete(
    # ID of an app to delete.
    id: ID!
  ): AppDelete
  # Creates a new token.
  appTokenCreate(
    # Fields required to create a new auth token.
    input: AppTokenInput!
  ): AppTokenCreate
  # Deletes an authentication token assigned to app.
  appTokenDelete(
    # ID of an auth token to delete.
    id: ID!
  ): AppTokenDelete
  # Verify provided app token.
  appTokenVerify(
    # App token to verify.
    token: String!
  ): AppTokenVerify
  # Install new app by using app manifest.
  appInstall(
    # Fields required to install a new app.
    input: AppInstallInput!
  ): AppInstall
  # Retry failed installation of new app.
  appRetryInstall(
    # Determine if app will be set active or not.
    activateAfterInstallation: Boolean = true
    # ID of failed installation.
    id: ID!
  ): AppRetryInstall
  # Delete failed installation.
  appDeleteFailedInstallation(
    # ID of failed installation to delete.
    id: ID!
  ): AppDeleteFailedInstallation
  # Fetch and validate manifest.
  appFetchManifest(manifestUrl: String!): AppFetchManifest
  # Activate the app.
  appActivate(
    # ID of app to activate.
    id: ID!
  ): AppActivate
  # Deactivate the app.
  appDeactivate(
    # ID of app to deactivate.
    id: ID!
  ): AppDeactivate
  # Create JWT token.
  tokenCreate(
    # Email of a user.
    email: String!
    # Password of a user.
    password: String!
  ): CreateToken
  # Refresh JWT token. Mutation tries to take refreshToken from the input.If it
  # fails it will try to take refreshToken from the http-only cookie
  # -refreshToken. csrfToken is required when refreshToken is provided as a cookie.
  tokenRefresh(
    # CSRF token required to refresh token. This argument is required when refreshToken is provided as a cookie.
    csrfToken: String
    # Refresh token.
    refreshToken: String
  ): RefreshToken
  # Verify JWT token.
  tokenVerify(
    # JWT token to validate.
    token: String!
  ): VerifyToken
  # Deactivate all JWT tokens of the currently authenticated user.
  tokensDeactivateAll: DeactivateAllUserTokens
  # Sends an email with the account password modification link.
  requestPasswordReset(
    # Email of the user that will be used for password recovery.
    email: String!
    # URL of a view where users should be redirected to reset the password. URL in RFC 1808 format.
    redirectUrl: String!
  ): RequestPasswordReset
  # Confirm user account with token sent by email during registration.
  confirmAccount(
    # E-mail of the user performing account confirmation.
    email: String!
    # A one-time token required to confirm the account.
    token: String!
  ): ConfirmAccount
  # Sets the user's password from the token sent by email using the RequestPasswordReset mutation.
  setPassword(
    # Email of a user.
    email: String!
    # Password of a user.
    password: String!
    # A one-time token required to set the password.
    token: String!
  ): SetPassword
  # Change the password of the logged in user.
  passwordChange(
    # New user password.
    newPassword: String!
    # Current user password.
    oldPassword: String!
  ): PasswordChange
  # Request email change of the logged in user.
  requestEmailChange(
    # New user email.
    newEmail: String!
    # User password.
    password: String!
    # URL of a view where users should be redirected to update the email address. URL in RFC 1808 format.
    redirectUrl: String!
  ): RequestEmailChange
  # Confirm the email change of the logged-in user.
  confirmEmailChange(
    # A one-time token required to change the email.
    token: String!
  ): ConfirmEmailChange
  # Create a new address for the customer.
  accountAddressCreate(
    # Fields required to create address.
    input: AddressInput!
    # A type of address. If provided, the new address will be automatically
    # assigned as the customer's default address of that type.
    type: AddressTypeEnum
  ): AccountAddressCreate
  # Updates an address of the logged-in user.
  accountAddressUpdate(
    # ID of the address to update.
    id: ID!
    # Fields required to update the address.
    input: AddressInput!
  ): AccountAddressUpdate
  # Delete an address of the logged-in user.
  accountAddressDelete(
    # ID of the address to delete.
    id: ID!
  ): AccountAddressDelete
  # Sets a default address for the authenticated user.
  accountSetDefaultAddress(
    # ID of the address to set as default.
    id: ID!
    # The type of address.
    type: AddressTypeEnum!
  ): AccountSetDefaultAddress
  # Register a new user.
  accountRegister(
    # Fields required to create a user.
    input: AccountRegisterInput!
  ): AccountRegister
  # Updates the account of the logged-in user.
  accountUpdate(
    # Fields required to update the account of the logged-in user.
    input: AccountInput!
  ): AccountUpdate
  # Sends an email with the account removal link for the logged-in user.
  accountRequestDeletion(
    # URL of a view where users should be redirected to delete their account. URL in RFC 1808 format.
    redirectUrl: String!
  ): AccountRequestDeletion
  # Remove user account.
  accountDelete(
    # A one-time token required to remove account. Sent by email using AccountRequestDeletion mutation.
    token: String!
  ): AccountDelete
  # Updates metadata of the logged-in user.
  accountUpdateMeta(
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): AccountUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation. This field will be removed after 2020-07-31."
    )
  # Creates user address.
  addressCreate(
    # Fields required to create address.
    input: AddressInput!
    # ID of a user to create address for.
    userId: ID!
  ): AddressCreate
  # Updates an address.
  addressUpdate(
    # ID of the address to update.
    id: ID!
    # Fields required to update the address.
    input: AddressInput!
  ): AddressUpdate
  # Deletes an address.
  addressDelete(
    # ID of the address to delete.
    id: ID!
  ): AddressDelete
  # Sets a default address for the given user.
  addressSetDefault(
    # ID of the address.
    addressId: ID!
    # The type of address.
    type: AddressTypeEnum!
    # ID of the user to change the address for.
    userId: ID!
  ): AddressSetDefault
  # Creates a new customer.
  customerCreate(
    # Fields required to create a customer.
    input: UserCreateInput!
  ): CustomerCreate
  # Updates an existing customer.
  customerUpdate(
    # ID of a customer to update.
    id: ID!
    # Fields required to update a customer.
    input: CustomerInput!
  ): CustomerUpdate
  # Deletes a customer.
  customerDelete(
    # ID of a customer to delete.
    id: ID!
  ): CustomerDelete
  # Deletes customers.
  customerBulkDelete(
    # List of user IDs to delete.
    ids: [ID]!
  ): CustomerBulkDelete
  # Creates a new staff user.
  staffCreate(
    # Fields required to create a staff user.
    input: StaffCreateInput!
  ): StaffCreate
  # Updates an existing staff user.
  staffUpdate(
    # ID of a staff user to update.
    id: ID!
    # Fields required to update a staff user.
    input: StaffUpdateInput!
  ): StaffUpdate
  # Deletes a staff user.
  staffDelete(
    # ID of a staff user to delete.
    id: ID!
  ): StaffDelete
  # Deletes staff users.
  staffBulkDelete(
    # List of user IDs to delete.
    ids: [ID]!
  ): StaffBulkDelete
  # Create a user avatar. Only for staff members. This mutation must be sent as a
  # `multipart` request. More detailed specs of the upload format can be found
  # here: https://github.com/jaydenseric/graphql-multipart-request-spec
  userAvatarUpdate(
    # Represents an image file in a multipart request.
    image: Upload!
  ): UserAvatarUpdate
  # Deletes a user avatar. Only for staff members.
  userAvatarDelete: UserAvatarDelete
  # Activate or deactivate users.
  userBulkSetActive(
    # List of user IDs to (de)activate).
    ids: [ID]!
    # Determine if users will be set active or not.
    isActive: Boolean!
  ): UserBulkSetActive
  # Updates metadata for user.
  userUpdateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): UserUpdateMeta
    @deprecated(
      reason: "Use the `updateMetadata` mutation. This field will be removed after 2020-07-31."
    )
  # Clear metadata for user.
  userClearMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): UserClearMeta
    @deprecated(
      reason: "Use the `deleteMetadata` mutation. This field will be removed after 2020-07-31."
    )
  # Updates private metadata for user.
  userUpdatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): UserUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation. This field will be removed after 2020-07-31."
    )
  # Clear private metadata for user.
  userClearPrivateMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): UserClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation. This field will be removed after 2020-07-31."
    )
  # Creates a new service account.
  serviceAccountCreate(
    # Fields required to create a new service account.
    input: ServiceAccountInput!
  ): ServiceAccountCreate
    @deprecated(
      reason: "Use the `appCreate` mutation instead. This field will be removed after 2020-07-31."
    )
  # Updates an existing service account.
  serviceAccountUpdate(
    # ID of a service account to update.
    id: ID!
    # Fields required to update an existing service account.
    input: ServiceAccountInput!
  ): ServiceAccountUpdate
    @deprecated(
      reason: "Use the `appUpdate` mutation instead. This field will be removed after 2020-07-31."
    )
  # Deletes a service account.
  serviceAccountDelete(
    # ID of a service account to delete.
    id: ID!
  ): ServiceAccountDelete
    @deprecated(
      reason: "Use the `appDelete` mutation instead. This field will be removed after 2020-07-31."
    )
  # Updates private metadata for a service account.
  serviceAccountUpdatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update new or stored metadata item.
    input: MetaInput!
  ): ServiceAccountUpdatePrivateMeta
    @deprecated(
      reason: "Use the `updatePrivateMetadata` mutation with App instead.This field will be removed after 2020-07-31."
    )
  # Clear private metadata for a service account.
  serviceAccountClearPrivateMetadata(
    # ID of a customer to update.
    id: ID!
    # Fields required to identify stored metadata item.
    input: MetaPath!
  ): ServiceAccountClearPrivateMeta
    @deprecated(
      reason: "Use the `deletePrivateMetadata` mutation with App instead.This field will be removed after 2020-07-31."
    )
  # Creates a new token.
  serviceAccountTokenCreate(
    # Fields required to create a new auth token.
    input: ServiceAccountTokenInput!
  ): ServiceAccountTokenCreate
    @deprecated(
      reason: "Use the `appTokenCreate` mutation instead. This field will be removed after 2020-07-31."
    )
  # Deletes an authentication token assigned to service account.
  serviceAccountTokenDelete(
    # ID of an auth token to delete.
    id: ID!
  ): ServiceAccountTokenDelete
    @deprecated(
      reason: "Use the `appTokenDelete` mutation instead. This field will be removed after 2020-07-31."
    )
  # Create new permission group.
  permissionGroupCreate(
    # Input fields to create permission group.
    input: PermissionGroupCreateInput!
  ): PermissionGroupCreate
  # Update permission group.
  permissionGroupUpdate(
    # ID of the group to update.
    id: ID!
    # Input fields to create permission group.
    input: PermissionGroupUpdateInput!
  ): PermissionGroupUpdate
  # Delete permission group.
  permissionGroupDelete(
    # ID of the group to delete.
    id: ID!
  ): PermissionGroupDelete
  # Export products to csv file.
  exportProductsV2(
    # Fields required to export product data
    input: ExportProductsV2Input!
  ): ExportProductsV2
  # Create a new File that is going to be hosted.
  createHostingFile(
    # Fields required to create a hosting file.
    input: HostingInput!
  ): CreateHostingFile
  # Delete a file that is hosted.
  deleteHostingFile(
    # ID of a hosted file.
    hostingId: ID!
  ): DeleteHostingFile
  # Create Notification.
  createNotification(
    # Fields required to create Notification.
    input: NotificationInput!
  ): CreateNotification
  # Requests for OTP for registered user.
  requestOtp(
    # Phone number of a user.
    phone: String!
    # Type of OTP.
    type: String
  ): RequestOTP
  # Create JWT token via OTP.
  otpTokenCreate(
    # Existing checkout id of the guest user, used to merge carts.
    checkoutId: ID
    # OTP of login session for user.
    otp: String!
    # Phone number of a user.
    phone: String!
  ): CreateTokenOTP
  # Requests for OTP for registered user.
  verifyCheckoutOtp(
    # OTP of login session for user.
    otp: String!
    # Phone number of a user.
    phone: String!
  ): VerifyCheckoutOTP
  # Requests for Token for registered user.
  tokenCreateWithAdmin(
    # User Id of a user.
    userId: String!
  ): TokenCreateWithAdmin
  # Register a new user.
  accountCreate(
    # Fields required to create a user.
    input: AccountCreateInput!
  ): AccountCreate
  # Register a new user with phone and email.
  accountRegisterV2(
    # Fields required to create a user.
    input: AccountRegisterInputV2!
  ): AccountRegisterV2
  # Confirm user account with otp sent by sms during registration.
  confirmAccountV2(
    # A one-time password required to confirm the account.
    otp: String!
    # Phone of the user performing account confirmation.
    phone: String!
  ): ConfirmAccountV2
  # Create a new product review.
  productReviewCreate(
    # Fields required to create Review.
    input: ProductReviewInput!
  ): CreateProductReview
  # Edit existing product review.
  productReviewEdit(
    # Review Id
    id: ID!
    # Fields to Edit Review.
    input: ProductReviewInput
  ): EditProductReview
  # Edit existing product review.
  productReviewDelete(
    # Review Id
    id: ID!
  ): DeleteProductReview
  # Create a product image. This mutation must be sent as a `multipart` request.
  # More detailed specs of the upload format can be found here:
  # https://github.com/jaydenseric/graphql-multipart-request-spec
  productImageCreateV2(
    # Fields required to create a product image.
    input: ProductImageCreateInput!
  ): ProductImageCreateV2
  # Create a product_review image. This mutation must be sent as a `multipart`
  # request. More detailed specs of the upload format can be found here:
  # https://github.com/jaydenseric/graphql-multipart-request-spec
  productReviewImageCreate(
    # Fields required to create a product_review image.
    input: ProductReviewImageCreateInput!
  ): ProductReviewImageCreate
  # Deletes a product_review image.
  productReviewImageDelete(
    # ID of a product_review image to delete.
    id: ID!
  ): ProductReviewImageDelete
  # Create a product_review video. This mutation must be sent as a `multipart`
  # request. More detailed specs of the upload format can be found here:
  # https://github.com/jaydenseric/graphql-multipart-request-spec
  productReviewVideoCreate(
    # Fields required to create a product_review video.
    input: ProductReviewVideoCreateInput!
  ): ProductReviewVideoCreate
  # Deletes a product_review video.
  productReviewVideoDelete(
    # ID of a product_review video to delete.
    id: ID!
  ): ProductReviewVideoDelete
  # Duplicates a product.
  productDuplicate(
    # ID of a product to duplicate.
    id: ID!
  ): ProductDuplicate
  # Creates an order on Razorpay.
  razorpayOrderCreate(
    # Parameters needed to create order on razorpay.
    input: RazorpayCreateOrderInput!
  ): CreateRazorpayOrder
  # Creates an order on Paytm.
  paytmOrderCreate(
    # Parameters needed to create order on paytm.
    input: PaytmCreateOrderInput!
  ): PaytmOrderCreate
  # Creates an order on Cashfree.
  cashfreeOrderCreate(
    # Parameters needed to create order on cashfree.
    input: CashfreeCreateOrderInput!
  ): CreateCashfreeOrder
  # Creates an order on Payu.
  payuOrderCreate(
    # Checkout ID.
    checkoutId: ID!
  ): CreatePayuOrder
  # Create a new banner
  bannerCreate(
    # Fields required to create a banner.
    input: BannerInput!
  ): CreateBanner
  # Update a banner
  bannerUpdate(
    # Id of the banner to update.
    id: ID!
    # Fields required to create a banner.
    input: BannerInput!
  ): UpdateBanner
  # Delete a banner
  bannerDelete(id: ID): DeleteBanner
  # Create a new header
  headerCreate(
    # Fields required to create a header.
    input: HeaderInput!
  ): CreateHeader
  # Create a new voucher rule.
  voucherRuleCreate(
    # Fields required to create a voucher rule.
    input: VoucherRuleInput!
  ): CreateVoucherRule
  # Update a voucher rule.
  voucherRuleUpdate(
    # ID of a voucher rule to update.
    id: ID!
    # Fields required to update a voucher rule.
    input: VoucherRuleInput!
  ): UpdateVoucherRule
  # Delete a voucher rule.
  voucherRuleDelete(
    # ID of a voucher rule to delete.
    id: ID!
  ): DeleteVoucherRule
  # Delete bulk voucher rules.
  voucherRuleBulkDelete(
    # List of voucherRule IDs to delete.
    ids: [ID]!
  ): DeleteBulkVoucherRule
  # Create a new voucher rule link to add promo code.
  voucherRuleLinkCreate(
    # Fields required to create a voucher rule link.
    input: VoucherRuleLinkInput!
  ): CreateVoucherRuleLink
  # Update a voucher rule link.
  voucherRuleLinkUpdate(
    # ID of a voucher rule link to update.
    id: ID!
    # Fields required to update a voucher rule link.
    input: VoucherRuleLinkInput!
  ): UpdateVoucherRuleLink
  # Set the payment method of checkout
  checkoutPaymentMethodUpdate(
    # Id of the checkout
    checkoutId: ID!
    # Gateway id to be selected
    gatewayId: String!
    # Whether to use previously earned cashback as discount
    useCashback: Boolean!
  ): UpdatePaymentMethod
  # Upload an invoice pdf.
  invoiceUpload(
    # Base64 encoded URI string of invoice pdf file.
    uri: String!
  ): InvoiceUpload
  # Update an address type
  addressTypeUpdate(
    # Id of the related object
    addressId: ID!
    # Type of address
    type: AddressTypes!
  ): UpdateAddressType
  # Push or sync an order to wareiq
  pushToWareiq(
    # Id of the order to push
    orderId: ID!
  ): PushToWareIq
  # Create a Partner.
  partnerCreate(
    # Represents an CSV file in a multipart request. Column name containing coupon code should be 'Code' in CSV File.
    csvFile: Upload
    # Fields required to create Partner.
    input: PartnerInput!
  ): PartnerCreate
  # Update a Partner.
  partnerUpdate(
    # Partner ID.
    id: ID!
    # Fields required to update Partner.
    input: PartnerInput!
  ): PartnerUpdate
  # Delete Partner.
  partnerDelete(
    # Partner ID.
    id: ID!
  ): PartnerDelete
  # Create Partner Coupons from CSV File
  partnerCouponCsvCreate(
    # CSV File Field required to create Partner Coupons.
    input: PartnerCouponCSVInput!
    # Partner ID.
    partnerId: ID!
    # Replace all Partner Coupons with new code from CSV
    replaceAll: Boolean
  ): PartnerCouponCSVCreate
  # Update Partner Coupon.
  partnerCouponUpdate(
    # Partner Coupon ID.
    id: ID!
    # Fields required to update a Partner Coupon.
    input: PartnerCouponInput!
  ): PartnerCouponUpdate
  # Delete Partner Coupon.
  partnerCouponDelete(
    # Partner Coupon ID.
    id: ID!
  ): PartnerCouponDelete
  # Create Partner Coupon Customer.
  partnerCouponCustomerCreate(
    # Fields required to create Partner Coupon Customer.
    input: PartnerCouponCustomerInput!
  ): PartnerCouponCustomerCreate
  # Update Partner Coupon Customer.
  partnerCouponCustomerUpdate(
    # Partner Coupon ID.
    id: ID!
    # Fields required to update a Partner Coupon Customer.
    input: PartnerCouponCustomerInput!
  ): PartnerCouponCustomerUpdate
  # Delete a Partner Coupon Customer
  partnerCouponCustomerDelete(
    # Partner Coupon Customer ID.
    id: ID!
  ): PartnerCouponCustomerDelete
  # Add/Sub Wallet Balance of a user
  walletBalanceUpdate(
    # Fields required to create Review.
    input: WalletInput!
  ): WalletBalanceUpdate
  # Push or sync all unsynced orders to wareiq
  pushAllToWareiq: PushAllToWareIq
  # Create a new ContactUs entry.
  contactUsCreate(
    # Fields required to create a ContactUs entry.
    input: ContactUsInput!
  ): ContactUsCreate
  # Create a new generic form entry.
  genericFormCreate(
    # Fields required to create a ContactUs entry.
    input: GenericFormInput!
  ): GenericFormCreate
  # Add a new pincode
  pincode(
    # Fields required to add a pincode.
    input: PincodeInput!
  ): Pincode
  # Creates a new combo.
  comboCreate(
    # Fields required to create a combo.
    input: ComboCreateInput!
  ): ComboCreate
  # Updates a combo.
  comboUpdate(
    # ID of a combo to update.
    id: ID!
    # Fields required to update a combo.
    input: ComboCreateInput!
  ): ComboUpdate
  # Deletes a combo.
  comboDelete(
    # ID of a combo to delete.
    id: ID!
  ): ComboDelete
  # Adds products to a combo.
  comboAddProductVariants(
    # ID of a combo.
    comboId: ID!
    # List of product variant IDs.
    variants: [ID]!
  ): ComboAddProductVariants
  # Adds products to a combo.
  comboRemoveProductVariants(
    # ID of a combo.
    comboId: ID!
    # List of product variant IDs.
    variants: [ID]!
  ): ComboRemoveProductVariants
  # Creates Shipments for Bluedart.
  bluedartShipmentCreate(
    # List of product IDs.
    orders: [ID]
  ): BluedartShipmentCreate
  # Create Survey.
  surveyCreate(
    # List of customer(user) ID(s) for which survey is created.
    customerIds: [ID]
    # Fields required to create a Survey.
    input: SurveyInput!
    # List of order ID(s) for which survey is created.
    orderIds: [ID]
    # List of Survey Question Input.
    questions: [SurveyQuestionInput]!
  ): SurveyCreate
  # Delete Survey.
  surveyDelete(
    # Survey ID.
    id: ID!
  ): SurveyDelete
  # Fill Survey.
  surveyFill(
    # List of SurveyAnswersType values.
    answers: [SurveyAnswerInput]!
    # Order ID for which Survey is given.
    orderId: ID
    # Survey unique hash for survey filling verification.
    surveyHash: String!
    # Survey ID
    surveyId: ID!
    # User ID for which Survey is given
    userId: ID
  ): SurveyFill
  # Sync Inventory with WareIq.
  syncWareiqInventory(
    # dummy field
    input: ID
  ): SyncWareIqInventory
  # Create Subscription.
  subscriptionCreate(
    # Fields required to create Review.
    input: SubscriptionInput!
  ): SubscriptionCreate
  # Update a subscription.
  subscriptionUpdate(
    # Subscription ID
    id: ID!
    # Fields to Edit subscription.
    input: SubscriptionInput
  ): UpdateSubscription
  # Delete a subscription.
  subscriptionDelete(
    # ID of subscription user to update.
    id: ID!
  ): DeleteSubscription
  # Create Influencer.
  createInfluencer(
    # Fields required to create Influencer.
    input: InfluencerInput!
  ): CreateInfluencer
  # Update an Influencer.
  updateInfluencer(
    # Influencer Id.
    id: ID!
    # Fields required to update Influencer
    input: InfluencerInput!
  ): UpdateInfluencer
  # Delete an Influencer instance.
  deleteInfluencer(
    # Influencer ID.
    id: ID!
  ): DeleteInfluencer
  # Create ShopifyUser.
  shopifyUserCreate(
    # Fields required to create ShopifyUser.
    input: ShopifyUserInput!
  ): CreateShopifyUser
  # Update an ShopifyUser.
  shopifyUserUpdate(
    # Fields required to update ShopifyUser
    input: ShopifyUserInput!
    # ShopifyUser Id.
    shopifyUserId: String!
  ): UpdateShopifyUser
  # Delete an ShopifyUser instance.
  shopifyUserDelete(
    # ShopifyUser ID.
    id: ID!
  ): DeleteShopifyUser
  # Creates a new section.
  sectionCreate(
    # Fields required to create a section.
    input: SectionInput!
    # ID of the parent section. If empty, category will be top level category.
    parent: ID
  ): SectionCreate
  # Updates a section.
  sectionUpdate(
    # ID of a section to update.
    id: ID!
    # Fields required to update a section.
    input: SectionInput!
  ): SectionUpdate
  # Deletes a section.
  sectionDelete(
    # ID of a section to delete.
    id: ID!
  ): SectionDelete
  # Adds products to a section.
  sectionAddProducts(
    # List of product IDs.
    products: [ID]!
    # ID of a section.
    sectionId: ID!
  ): SectionAddProducts
  # Remove products from a section.
  sectionRemoveProducts(
    # List of product IDs.
    products: [ID]!
    # ID of a section.
    sectionId: ID!
  ): SectionRemoveProducts
  # Reorder the products of a section.
  sectionReorderProducts(
    # The section products position operations.
    moves: [MoveProductInput]!
    # ID of a section.
    sectionId: ID!
  ): SectionReorderProducts
  # Create a product image. This mutation must be sent as a `multipart` request.
  # More detailed specs of the upload format can be found here:
  # https://github.com/jaydenseric/graphql-multipart-request-spec
  sectionImageCreate(
    # Fields required to create a section image.
    input: SectionImageCreateInput!
  ): SectionImageCreate
  # Deletes a section image.
  sectionImageDelete(
    # ID of a Section image to delete.
    id: ID!
  ): SectionImageDelete
  # Changes ordering of the section image.
  sectionImageReorder(
    # IDs of a section images in the desired order.
    imagesIds: [ID]!
    # Id of product that images order will be altered.
    sectionId: ID!
  ): SectionImageReorder
  # Updates metadata of an object.
  updateMetadataV2(
    # ID of an object to update.
    id: ID!
    # Fields required to update the object's metadata.
    input: [MetadataInputV2!]!
  ): UpdateMetadataV2
  # Delete metadata of an object.
  deleteMetadataV2(
    # ID of an object to update.
    id: ID!
    # Metadata keys to delete.
    keys: [String!]!
  ): DeleteMetadataV2
  # Updates private metadata of an object.
  updatePrivateMetadataV2(
    # ID of an object to update.
    id: ID!
    # Fields required to update the object's metadata.
    input: [MetadataInputV2!]!
  ): UpdatePrivateMetadataV2
  # Delete object's private metadata.
  deletePrivateMetadataV2(
    # ID of an object to update.
    id: ID!
    # Metadata keys to delete.
    keys: [String!]!
  ): DeletePrivateMetadataV2
  # Create ShopifyUser.
  checkoutAddPromoCodeShopify(
    # Checkout ID.
    checkoutId: ID!
    # Gift card code or voucher code.
    promoCode: String!
  ): checkoutAddPromoCodeShopify
  # Create ShopifyUser.
  checkoutRemovePromoCodeShopify(
    # Checkout ID.
    checkoutId: ID!
  ): checkoutRemovePromoCodeShopify
  # Create a user avatar. For all users. This mutation must be sent as a
  # `multipart` request. More detailed specs of the upload format can be found
  # here: https://github.com/jaydenseric/graphql-multipart-request-spec
  userAvatarUpdateV2(
    # Represents an image file in a multipart request.
    image: Upload!
  ): UserAvatarUpdateV2
  # Deletes a user avatar. Only for staff members.
  userAvatarDeleteV2: UserAvatarDeleteV2
  # Cancel a DTC Order
  dtcOrderCancel(
    # Fields required to cancel a DTC Order
    input: OrderCancelInput!
  ): DtcOrderCancel
  # Return a DTC Order
  dtcOrderReturn(
    # Fields required to return a DTC Order
    input: OrderReturnInput!
  ): DtcOrderReturn
  # Create a menu item image. This mutation must be sent as a `multipart` request.
  # More detailed specs of the upload format can be found here:
  # https://github.com/jaydenseric/graphql-multipart-request-spec
  menuItemImageCreate(
    # Fields required to create a product_review image.
    input: CreateMenuItemsImagesInput!
  ): CreateMenuItemsImages
  # Moves items of menus.
  menuItemMoveV2(
    # ID of the menu.
    menu: ID!
    # The menu position data.
    moves: [MenuItemMoveInput]!
  ): MenuItemMoveV2
  # Create Product.
  createProductCsv(
    # Represents an CSV file in a multipart request.
    csvFile: Upload!
  ): CreateProductCSV
  # Create Product.
  createProductVariantCsv(
    # Represents an CSV file in a multipart request.
    csvFile: Upload!
  ): CreateProductVariantCSV
  # Update Product Pricing on Shopify.
  updateShopifyProductPriceCsv(
    # Represents an CSV file in a multipart request.
    csvFile: Upload!
  ): UpdateShopifyProductPriceCSV
  # Update Product Tags on Shopify.
  updateShopifyProductTagsCsv(
    # Represents an CSV file in a multipart request.
    csvFile: Upload!
  ): UpdateShopifyProductTagsCSV
  # Updates a list ProductVariant quantities
  productVariantBulkUpdate(
    # A list of objects containing variant_ids and quantities
    variants: [VariantInput]
  ): ProductVariantBulkUpdate
}

input NameTranslationInput {
  name: String
}

# Represents shop's navigation menus.
type Navigation {
  # Main navigation bar.
  main: Menu
  # Secondary navigation bar.
  secondary: Menu
}

enum NavigationType {
  # Main storefront navigation.
  MAIN
  # Secondary storefront navigation.
  SECONDARY
}

# An object with an ID
interface Node {
  # The ID of the object.
  id: ID!
}

# Single Notification Details
input NotificationInput {
  # Product Id
  productId: ID!
  # User email.
  email: String!
  # User phone No.
  phone: String!
  # First name of User
  name: String!
}

type NotificationType implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  email: String!
  phone: String!
  product: Product!
  created: DateTime!
  isNotified: Boolean!
}

interface ObjectWithMetadata {
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
}

interface ObjectWithMetadataV2 {
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItemV2]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItemV2]!
}

# Represents an order in the shop.
type Order implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  created: DateTime!
  status: OrderStatus!
  user: User
  languageCode: String!
  trackingClientId: String!
  billingAddress: Address
  shippingAddress: Address
  shippingMethod: ShippingMethod
  shippingMethodName: String
  # Total price of shipping.
  shippingPrice: TaxedMoney
  token: String!
  voucher: Voucher
  # List of user gift cards.
  giftCards: [GiftCard]
  discount: Money
  discountName: String
  translatedDiscountName: String
  displayGrossPrices: Boolean!
  customerNote: String!
  weight: Weight
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # List of shipments for the order.
  fulfillments: [Fulfillment]!
  # List of order lines.
  lines: [OrderLine]!
  # List of actions that can be performed in the current state of an order.
  actions: [OrderAction]!
  # Shipping methods that can be used with this order.
  availableShippingMethods: [ShippingMethod]
  # List of order invoices.
  invoices: [Invoice]
  # User-friendly number of an order.
  number: String
  # Informs if an order is fully paid.
  isPaid: Boolean
  # Internal payment status.
  paymentStatus: PaymentChargeStatusEnum
  # User-friendly payment status.
  paymentStatusDisplay: String
  # List of payments for the order.
  payments: [Payment]
  # Total amount of the order.
  total: TaxedMoney
  # The sum of line prices not including shipping.
  subtotal: TaxedMoney
  # User-friendly order status.
  statusDisplay: String
  # Informs whether a draft order can be finalized(turned into a regular order).
  canFinalize: Boolean!
  # Amount authorized for the order.
  totalAuthorized: Money
  # Amount captured by payment.
  totalCaptured: Money
  # List of events associated with the order.
  events: [OrderEvent]
  # The difference between the paid and the order total amount.
  totalBalance: Money!
  # Email address of the customer.
  userEmail: String
  # Returns True, if order requires shipping.
  isShippingRequired: Boolean!
}

enum OrderAction {
  # Represents the capture action.
  CAPTURE
  # Represents a mark-as-paid action.
  MARK_AS_PAID
  # Represents a refund action.
  REFUND
  # Represents a void action.
  VOID
}

# Adds note to the order.
type OrderAddNote {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Order with the note added.
  order: Order
  # Order note created.
  event: OrderEvent
  orderErrors: [OrderError!]!
}

input OrderAddNoteInput {
  # Note message.
  message: String!
}

# Cancels orders.
type OrderBulkCancel {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  orderErrors: [OrderError!]!
}

# Cancel an order.
type OrderCancel {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Canceled order.
  order: Order
  orderErrors: [OrderError!]!
}

input OrderCancelInput {
  # Order ID
  orderId: String!
  # Customer ID
  customerId: String!
  # Reason for Order Cancellation
  reason: String!
  # Comments
  comment: String
}

# Capture an order.
type OrderCapture {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Captured order.
  order: Order
  orderErrors: [OrderError!]!
}

# Clears stored metadata value.
type OrderClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  order: Order
}

# Clears stored private metadata value.
type OrderClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  order: Order
}

type OrderCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [OrderCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type OrderCountableEdge {
  # The item at the end of the edge.
  node: Order!
  # A cursor for use in pagination.
  cursor: String!
}

enum OrderDirection {
  # Specifies an ascending sort order.
  ASC
  # Specifies a descending sort order.
  DESC
}

input OrderDraftFilterInput {
  customer: String
  created: DateRangeInput
  search: String
}

type OrderError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: OrderErrorCode!
  # Warehouse ID which causes the error.
  warehouse: ID
  # Order line ID which causes the error.
  orderLine: ID
}

# An enumeration.
enum OrderErrorCode {
  BILLING_ADDRESS_NOT_SET
  CANNOT_CANCEL_FULFILLMENT
  CANNOT_CANCEL_ORDER
  CANNOT_DELETE
  CANNOT_REFUND
  CAPTURE_INACTIVE_PAYMENT
  NOT_EDITABLE
  FULFILL_ORDER_LINE
  GRAPHQL_ERROR
  INVALID
  PRODUCT_NOT_PUBLISHED
  PRODUCT_UNAVAILABLE_FOR_PURCHASE
  NOT_FOUND
  ORDER_NO_SHIPPING_ADDRESS
  PAYMENT_ERROR
  PAYMENT_MISSING
  REQUIRED
  SHIPPING_METHOD_NOT_APPLICABLE
  SHIPPING_METHOD_REQUIRED
  TAX_ERROR
  UNIQUE
  VOID_INACTIVE_PAYMENT
  ZERO_QUANTITY
  INSUFFICIENT_STOCK
  DUPLICATED_INPUT_ITEM
}

# History log of the order.
type OrderEvent implements Node {
  # The ID of the object.
  id: ID!
  # Date when event happened at in ISO 8601 format.
  date: DateTime
  # Order event type.
  type: OrderEventsEnum
  # User who performed the action.
  user: User
  # Content of the event.
  message: String
  # Email of the customer.
  email: String
  # Type of an email sent to the customer.
  emailType: OrderEventsEmailsEnum
  # Amount of money.
  amount: Float
  # The payment ID from the payment gateway.
  paymentId: String
  # The payment gateway of the payment.
  paymentGateway: String
  # Number of items.
  quantity: Int
  # Composed ID of the Fulfillment.
  composedId: String
  # User-friendly number of an order.
  orderNumber: String
  # Number of an invoice related to the order.
  invoiceNumber: String
  # List of oversold lines names.
  oversoldItems: [String]
  # The concerned lines.
  lines: [OrderEventOrderLineObject]
  # The lines fulfilled.
  fulfilledItems: [FulfillmentLine]
  # The warehouse were items were restocked.
  warehouse: Warehouse
}

type OrderEventCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [OrderEventCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type OrderEventCountableEdge {
  # The item at the end of the edge.
  node: OrderEvent!
  # A cursor for use in pagination.
  cursor: String!
}

type OrderEventOrderLineObject {
  # The variant quantity.
  quantity: Int
  # The order line.
  orderLine: OrderLine
  # The variant name.
  itemName: String
}

# An enumeration.
enum OrderEventsEmailsEnum {
  PAYMENT_CONFIRMATION
  SHIPPING_CONFIRMATION
  TRACKING_UPDATED
  ORDER_CONFIRMATION
  ORDER_CANCEL
  ORDER_REFUND
  FULFILLMENT_CONFIRMATION
  DIGITAL_LINKS
}

# An enumeration.
enum OrderEventsEnum {
  DRAFT_CREATED
  DRAFT_ADDED_PRODUCTS
  DRAFT_REMOVED_PRODUCTS
  PLACED
  PLACED_FROM_DRAFT
  OVERSOLD_ITEMS
  CANCELED
  ORDER_MARKED_AS_PAID
  ORDER_FULLY_PAID
  UPDATED_ADDRESS
  EMAIL_SENT
  PAYMENT_AUTHORIZED
  PAYMENT_CAPTURED
  EXTERNAL_SERVICE_NOTIFICATION
  PAYMENT_REFUNDED
  PAYMENT_VOIDED
  PAYMENT_FAILED
  INVOICE_REQUESTED
  INVOICE_GENERATED
  INVOICE_UPDATED
  INVOICE_SENT
  FULFILLMENT_CANCELED
  FULFILLMENT_RESTOCKED_ITEMS
  FULFILLMENT_FULFILLED_ITEMS
  TRACKING_UPDATED
  NOTE_ADDED
  OTHER
}

input OrderFilterInput {
  paymentStatus: [PaymentChargeStatusEnum]
  status: [OrderStatusFilter]
  customer: String
  created: DateRangeInput
  search: String
}

# Creates new fulfillments for an order.
type OrderFulfill {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # List of created fulfillments.
  fulfillments: [Fulfillment]
  # Fulfilled order.
  order: Order
  orderErrors: [OrderError!]!
}

input OrderFulfillInput {
  # List of items informing how to fulfill the order.
  lines: [OrderFulfillLineInput!]!
  # If true, send an email notification to the customer.
  notifyCustomer: Boolean
}

input OrderFulfillLineInput {
  # The ID of the order line.
  orderLineId: ID
  # List of stock items to create.
  stocks: [OrderFulfillStockInput!]!
}

input OrderFulfillStockInput {
  # The number of line items to be fulfilled from given warehouse.
  quantity: Int!
  # ID of the warehouse from which the item will be fulfilled.
  warehouse: ID!
}

# Represents order line of particular order.
type OrderLine implements Node {
  # The ID of the object.
  id: ID!
  productName: String!
  variantName: String!
  productSku: String!
  isShippingRequired: Boolean!
  quantity: Int!
  quantityFulfilled: Int!
  taxRate: Float!
  digitalContentUrl: DigitalContentUrl
  # The main thumbnail for the ordered product.
  thumbnail(
    # Size of thumbnail.
    size: Int
  ): Image
  # Price of the single item in the order line.
  unitPrice: TaxedMoney
  # Price of the order line.
  totalPrice: TaxedMoney
  # A purchased product variant. Note: this field may be null if the variant has been removed from stock at all.
  variant: ProductVariant
  # Product name in the customer's language
  translatedProductName: String!
  # Variant name in the customer's language
  translatedVariantName: String!
  # List of allocations across warehouses.
  allocations: [Allocation!]
}

input OrderLineCreateInput {
  # Number of variant items ordered.
  quantity: Int!
  # Product variant ID.
  variantId: ID!
}

input OrderLineInput {
  # Number of variant items ordered.
  quantity: Int!
}

# Mark order as manually paid.
type OrderMarkAsPaid {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Order marked as paid.
  order: Order
  orderErrors: [OrderError!]!
}

# Refund an order.
type OrderRefund {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A refunded order.
  order: Order
  orderErrors: [OrderError!]!
}

input OrderReturnInput {
  # Order ID
  orderId: String!
  # Customer ID
  customerId: String!
  # Reason for Order Return
  reason: String!
  # Line Item ID
  lineItemId: [String]!
  # Quantity
  quantity: [Int]!
  # Comments
  comment: String
}

enum OrderSortField {
  # Sort orders by number.
  NUMBER
  # Sort orders by creation date.
  CREATION_DATE
  # Sort orders by customer.
  CUSTOMER
  # Sort orders by payment.
  PAYMENT
  # Sort orders by fulfillment status.
  FULFILLMENT_STATUS
  # Sort orders by total.
  TOTAL
}

input OrderSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort orders by the selected field.
  field: OrderSortField!
}

# An enumeration.
enum OrderStatus {
  # Draft
  DRAFT
  # Unfulfilled
  UNFULFILLED
  # Partially fulfilled
  PARTIALLY_FULFILLED
  # Fulfilled
  FULFILLED
  # Canceled
  CANCELED
}

enum OrderStatusFilter {
  READY_TO_FULFILL
  READY_TO_CAPTURE
  UNFULFILLED
  PARTIALLY_FULFILLED
  FULFILLED
  CANCELED
}

# Updates an order.
type OrderUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  orderErrors: [OrderError!]!
  order: Order
}

input OrderUpdateInput {
  # Billing address of the customer.
  billingAddress: AddressInput
  # Email address of the customer.
  userEmail: String
  # Shipping address of the customer.
  shippingAddress: AddressInput
}

# Updates meta for order.
type OrderUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  order: Order
}

# Updates private meta for order.
type OrderUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  order: Order
}

# Updates a shipping method of the order.
type OrderUpdateShipping {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Order with updated shipping method.
  order: Order
  orderErrors: [OrderError!]!
}

input OrderUpdateShippingInput {
  # ID of the selected shipping method.
  shippingMethod: ID
}

# Void an order.
type OrderVoid {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A voided order.
  order: Order
  orderErrors: [OrderError!]!
}

type OTPError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: OTPErrorCodeEnum
}

# An enumeration.
enum OTPErrorCodeEnum {
  INVALID_PHONE
  INVALID_OTP
}

# A static page that can be manually added by a shop operator through the dashboard.
type Page implements Node & ObjectWithMetadata {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  title: String!
  contentJson: JSONString!
  publicationDate: Date
  slug: String!
  created: DateTime!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # Content of the page.
  content: String! @deprecated(reason: "Use the `contentJson` field instead.")
  # Returns translated page fields for the given language code.
  translation(
    # A language code to return the translation for page.
    languageCode: LanguageCodeEnum!
  ): PageTranslation
  # Whether the page is published.
  isPublished: Boolean!
}

# Deletes pages.
type PageBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  pageErrors: [PageError!]!
}

# Publish pages.
type PageBulkPublish {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  pageErrors: [PageError!]!
}

type PageCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [PageCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type PageCountableEdge {
  # The item at the end of the edge.
  node: Page!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new page.
type PageCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  pageErrors: [PageError!]!
  page: Page
}

# Deletes a page.
type PageDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  pageErrors: [PageError!]!
  page: Page
}

type PageError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PageErrorCode!
}

# An enumeration.
enum PageErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

input PageFilterInput {
  search: String
}

# The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!
  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!
  # When paginating backwards, the cursor to continue.
  startCursor: String
  # When paginating forwards, the cursor to continue.
  endCursor: String
}

input PageInput {
  # Page internal name.
  slug: String
  # Page title.
  title: String
  # Page content. May consist of ordinary text, HTML and images.
  content: String
  # Page content in JSON format.
  contentJson: JSONString
  # Determines if page is visible in the storefront.
  isPublished: Boolean
  # Publication date. ISO 8601 standard.
  publicationDate: String
  # Search engine optimization fields.
  seo: SeoInput
}

enum PageSortField {
  # Sort pages by title.
  TITLE
  # Sort pages by slug.
  SLUG
  # Sort pages by visibility.
  VISIBILITY
  # Sort pages by creation date.
  CREATION_DATE
  # Sort pages by publication date.
  PUBLICATION_DATE
}

input PageSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort pages by the selected field.
  field: PageSortField!
}

type PageTranslatableContent implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  title: String!
  contentJson: JSONString!
  # Content of the page.
  content: String! @deprecated(reason: "Use the `contentJson` field instead.")
  # Returns translated page fields for the given language code.
  translation(
    # A language code to return the translation for page.
    languageCode: LanguageCodeEnum!
  ): PageTranslation
  # ('A static page that can be manually added by a shop operator ', 'through the dashboard.')
  page: Page
}

# Creates/Updates translations for Page.
type PageTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  page: PageTranslatableContent
}

type PageTranslation implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  title: String!
  contentJson: JSONString!
  # Translation language.
  language: LanguageDisplay!
  # Translated description of the page.
  content: String! @deprecated(reason: "Use the `contentJson` field instead.")
}

input PageTranslationInput {
  seoTitle: String
  seoDescription: String
  title: String
  content: String
  contentJson: JSONString
}

# Updates an existing page.
type PageUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  pageErrors: [PageError!]!
  page: Page
}

# Create Partner Coupons from CSV File
type PartnerCouponCSVCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Partner Instance.
  partner: PartnerType
  partnerCouponErrors: [PartnerCouponError!]!
}

input PartnerCouponCSVInput {
  # Represents an CSV file in a multipart request. Column name containing coupon code should be 'Code' in CSV File.
  csvFile: Upload!
}

# Create Partner Coupon Customer.
type PartnerCouponCustomerCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Partner Coupon Customer instance.
  partnerCouponCustomer: PartnerCouponCustomerType
  partnerCouponCustomerErrors: [PartnerCouponCustomerError!]!
}

# Delete a Partner Coupon Customer
type PartnerCouponCustomerDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Partner Coupon Customer instance.
  partnerCouponCustomer: PartnerCouponCustomerType
  partnerCouponCustomerErrors: [PartnerCouponCustomerError!]!
}

type PartnerCouponCustomerError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PartnerCouponCustomerErrorCode!
}

# An enumeration.
enum PartnerCouponCustomerErrorCode {
  REQUIRED
  INVALID
}

input PartnerCouponCustomerInput {
  # Partner Coupon ID.
  partnerCouponId: ID!
  # Customer email.
  customerEmail: String!
}

type PartnerCouponCustomerType implements Node {
  # The ID of the object.
  id: ID!
  partnerCoupon: PartnerCouponType!
  customerEmail: String!
}

type PartnerCouponCustomerTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [PartnerCouponCustomerTypeEdge]!
}

# A Relay edge containing a `PartnerCouponCustomerType` and its cursor.
type PartnerCouponCustomerTypeEdge {
  # The item at the end of the edge
  node: PartnerCouponCustomerType
  # A cursor for use in pagination
  cursor: String!
}

# Update Partner Coupon Customer.
type PartnerCouponCustomerUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Partner Coupon Customer instance.
  partnerCouponCustomer: PartnerCouponCustomerType
  partnerCouponCustomerErrors: [PartnerCouponCustomerError!]!
}

# Delete Partner Coupon.
type PartnerCouponDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Partner Coupon instance.
  partnerCoupon: PartnerCouponType
  partnerCouponErrors: [PartnerCouponError!]!
}

type PartnerCouponError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PartnerCouponErrorCode!
}

# An enumeration.
enum PartnerCouponErrorCode {
  INVALID
  CSV_FILE_INVALID
  REQUIRED
}

input PartnerCouponInput {
  # Name of Partner Coupon.
  name: String
  # Optional description of Partner Coupon.
  description: String
  # Code of Partner Coupon.
  code: String
  # How many times this Partner Coupon is used by customers.
  used: Int
}

type PartnerCouponType implements Node {
  # The ID of the object.
  id: ID!
  partner: PartnerType!
  name: String
  description: String
  code: String!
  used: Int!
  created: DateTime!
  updated: DateTime!
  customers(
    before: String
    after: String
    first: Int
    last: Int
  ): PartnerCouponCustomerTypeConnection!
}

type PartnerCouponTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [PartnerCouponTypeEdge]!
}

# A Relay edge containing a `PartnerCouponType` and its cursor.
type PartnerCouponTypeEdge {
  # The item at the end of the edge
  node: PartnerCouponType
  # A cursor for use in pagination
  cursor: String!
}

# Update Partner Coupon.
type PartnerCouponUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Partner Coupon instance.
  partnerCoupon: PartnerCouponType
  partnerCouponErrors: [PartnerCouponError!]!
}

# Create a Partner.
type PartnerCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Partner instance.
  partner: PartnerType
  partnerErrors: [PartnerError!]!
}

# Delete Partner.
type PartnerDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Partner instane.
  partner: PartnerType
  partnerErrors: [PartnerError!]!
}

type PartnerError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PartnerErrorCode!
}

# An enumeration.
enum PartnerErrorCode {
  PARTNER_INVALID
  NAME_REQUIRED
  START_DATE_INVALID
  END_DATE_INVALID
}

input PartnerInput {
  # Name of Partner.
  name: String!
  # Optional description of Partner.
  description: String
  # Event Name used for Partner coupon events
  eventName: String
  # Usage limit per customer for Partner's coupons.
  usageLimit: Int
  # Apply this Partner's coupons once per customer.
  applyOncePerCustomer: Boolean
  # Min Spent Amount for a Partner's coupon to be valid.
  minSpentAmount: Int
  # Start date of the Partner.
  startDate: DateTime
  # End date of the Partner.
  endDate: DateTime
  # Partner is active or inactive.
  isActive: Boolean
}

type PartnerType implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  description: String
  eventName: String!
  usageLimit: Int
  applyOncePerCustomer: Boolean!
  currency: String!
  minSpentAmount: Float
  minSpent: Money
  startDate: DateTime!
  endDate: DateTime
  created: DateTime!
  updated: DateTime!
  isActive: Boolean!
  partnerCoupons(
    before: String
    after: String
    first: Int
    last: Int
  ): PartnerCouponTypeConnection!
}

type PartnerTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [PartnerTypeEdge]!
}

# A Relay edge containing a `PartnerType` and its cursor.
type PartnerTypeEdge {
  # The item at the end of the edge
  node: PartnerType
  # A cursor for use in pagination
  cursor: String!
}

# Update a Partner.
type PartnerUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Partner instance.
  partner: PartnerType
  partnerErrors: [PartnerError!]!
}

# Change the password of the logged in user.
type PasswordChange {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A user instance with a new password.
  user: User
  accountErrors: [AccountError!]!
}

# Represents a payment of a given type.
type Payment implements Node {
  # The ID of the object.
  id: ID!
  gateway: String!
  isActive: Boolean!
  created: DateTime!
  modified: DateTime!
  token: String!
  checkout: CheckoutType
  order: Order
  customerIpAddress: String
  # Internal payment status.
  chargeStatus: PaymentChargeStatusEnum!
  # List of actions that can be performed in the current state of a payment.
  actions: [OrderAction]!
  # Total amount of the payment.
  total: Money
  # Total amount captured for this payment.
  capturedAmount: Money
  # List of all transactions within this payment.
  transactions: [Transaction]
  # Maximum amount of money that can be captured.
  availableCaptureAmount: Money
  # Maximum amount of money that can be refunded.
  availableRefundAmount: Money
  # The details of the card used for this payment.
  creditCard: CreditCard
}

# Captures the authorized payment amount.
type PaymentCapture {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated payment.
  payment: Payment
  paymentErrors: [PaymentError!]!
}

# An enumeration.
enum PaymentChargeStatusEnum {
  NOT_CHARGED
  PENDING
  PARTIALLY_CHARGED
  FULLY_CHARGED
  PARTIALLY_REFUNDED
  FULLY_REFUNDED
  REFUSED
  CANCELLED
}

type PaymentCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [PaymentCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type PaymentCountableEdge {
  # The item at the end of the edge.
  node: Payment!
  # A cursor for use in pagination.
  cursor: String!
}

type PaymentError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PaymentErrorCode!
}

# An enumeration.
enum PaymentErrorCode {
  BILLING_ADDRESS_NOT_SET
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
  PARTIAL_PAYMENT_NOT_ALLOWED
  SHIPPING_ADDRESS_NOT_SET
  INVALID_SHIPPING_METHOD
  SHIPPING_METHOD_NOT_SET
  PAYMENT_ERROR
  NOT_SUPPORTED_GATEWAY
}

# Available payment gateway backend with configuration necessary to setup client.
type PaymentGateway {
  # Payment gateway name.
  name: String!
  # Payment gateway ID.
  id: ID!
  # Payment gateway client configuration.
  config: [GatewayConfigLine!]!
  # Payment gateway supported currencies.
  currencies: [String]!
}

# Initializes payment process when it is required by gateway.
type PaymentInitialize {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  initializedPayment: PaymentInitialized
  paymentErrors: [PaymentError!]!
}

# Server-side data generated by a payment gateway. Optional step when the payment
# provider requires an additional action to initialize payment session.
type PaymentInitialized {
  # ID of a payment gateway.
  gateway: String!
  # Payment gateway name.
  name: String!
  # Initialized data by gateway.
  data: JSONString
}

input PaymentInput {
  # A gateway to use with that payment.
  gateway: String!
  # Client-side generated payment token, representing customer's billing data in a secure manner.
  token: String
  # Total amount of the transaction, including all taxes and discounts. If no
  # amount is provided, the checkout total will be used.
  amount: PositiveDecimal
  # [Deprecated] Billing address. If empty, the billing address associated with
  # the checkout instance will be used. Use `checkoutCreate` or
  # `checkoutBillingAddressUpdate` mutations to set it. This field will be removed
  # after 2020-07-31.
  billingAddress: AddressInput
  # URL of a storefront view where user should be redirected after requiring
  # additional actions. Payment with additional actions will not be finished if
  # this field is not provided.
  returnUrl: String
}

# Refunds the captured payment amount.
type PaymentRefund {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated payment.
  payment: Payment
  paymentErrors: [PaymentError!]!
}

# Represents a payment source stored for user in payment gateway, such as credit card.
type PaymentSource {
  # Payment gateway name.
  gateway: String!
  # Stored credit card details if available.
  creditCardInfo: CreditCard
}

# Voids the authorized payment.
type PaymentVoid {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated payment.
  payment: Payment
  paymentErrors: [PaymentError!]!
}

input PaytmCreateOrderInput {
  # Checkout ID.
  checkoutId: ID
  # Email of the User.
  email: String!
}

type PaytmError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PaytmErrorCodeEnum
}

# An enumeration.
enum PaytmErrorCodeEnum {
  INVALID_AMOUNT
  INVALID_CURRENCY
  INVALID
}

# Creates an order on Paytm.
type PaytmOrderCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Paytm order object.
  paytmOrder: PaytmOrderType
  paytmErrors: [PaytmError!]!
}

type PaytmOrderType {
  # Paytm Txn Token.
  txnToken: String
  # Token status.
  status: String
  # Order ID.
  orderId: String
  # Token creation timestamp.
  createdAt: String
  # Merchant ID
  merchantId: String
  # Callback url
  callbackUrl: String
}

type PayuOrderType {
  # PayU Order ID.
  token: String
  # PayU Payment url to use.
  paymentUrl: String
  # Form fields to POST to payment url.
  payload: JSONString
}

# Represents a permission object in a friendly form.
type Permission {
  # Internal code for permission.
  code: PermissionEnum!
  # Describe action(s) allowed to do by permission.
  name: String!
}

# An enumeration.
enum PermissionEnum {
  MANAGE_USERS
  MANAGE_STAFF
  MANAGE_SERVICE_ACCOUNTS
  MANAGE_APPS
  MANAGE_DISCOUNTS
  MANAGE_PLUGINS
  MANAGE_GIFT_CARD
  MANAGE_MENUS
  MANAGE_ORDERS
  MANAGE_PAGES
  MANAGE_PRODUCTS
  MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES
  MANAGE_SHIPPING
  MANAGE_SETTINGS
  MANAGE_TRANSLATIONS
  MANAGE_CHECKOUTS
}

# Create new permission group.
type PermissionGroupCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  permissionGroupErrors: [PermissionGroupError!]!
  group: Group
}

input PermissionGroupCreateInput {
  # List of permission code names to assign to this group.
  addPermissions: [PermissionEnum!]
  # List of users to assign to this group.
  addUsers: [ID!]
  # Group name.
  name: String!
}

# Delete permission group.
type PermissionGroupDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  permissionGroupErrors: [PermissionGroupError!]!
  group: Group
}

type PermissionGroupError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PermissionGroupErrorCode!
  # List of permissions which causes the error.
  permissions: [PermissionEnum!]
  # List of user IDs which causes the error.
  users: [ID!]
}

# An enumeration.
enum PermissionGroupErrorCode {
  ASSIGN_NON_STAFF_MEMBER
  DUPLICATED_INPUT_ITEM
  CANNOT_REMOVE_FROM_LAST_GROUP
  LEFT_NOT_MANAGEABLE_PERMISSION
  OUT_OF_SCOPE_PERMISSION
  OUT_OF_SCOPE_USER
  REQUIRED
  UNIQUE
}

input PermissionGroupFilterInput {
  search: String
}

enum PermissionGroupSortField {
  # Sort permission group accounts by name.
  NAME
}

input PermissionGroupSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort permission group by the selected field.
  field: PermissionGroupSortField!
}

# Update permission group.
type PermissionGroupUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  permissionGroupErrors: [PermissionGroupError!]!
  group: Group
}

input PermissionGroupUpdateInput {
  # List of permission code names to assign to this group.
  addPermissions: [PermissionEnum!]
  # List of users to assign to this group.
  addUsers: [ID!]
  # Group name.
  name: String
  # List of permission code names to unassign from this group.
  removePermissions: [PermissionEnum!]
  # List of users to unassign from this group.
  removeUsers: [ID!]
}

# Add a new pincode
type Pincode {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A pincode instance.
  pincode: PincodeType
}

input PincodeInput {
  # Pincode
  pin: String!
  # City of the pincode
  city: String
  # State of the pincode
  state: String
  # If the pincode is servicable
  serviceable: Boolean
}

type PincodeType implements Node {
  pin: String!
  city: String!
  state: String!
  serviceable: Boolean!
  created: DateTime!
  updated: DateTime!
  # The ID of the object.
  id: ID!
}

type PincodeTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [PincodeTypeEdge]!
}

# A Relay edge containing a `PincodeType` and its cursor.
type PincodeTypeEdge {
  # The item at the end of the edge
  node: PincodeType
  # A cursor for use in pagination
  cursor: String!
}

# Plugin.
type Plugin implements Node {
  id: ID!
  name: String!
  description: String!
  active: Boolean!
  configuration: [ConfigurationItem]
}

type PluginCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [PluginCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type PluginCountableEdge {
  # The item at the end of the edge.
  node: Plugin!
  # A cursor for use in pagination.
  cursor: String!
}

type PluginError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PluginErrorCode!
}

# An enumeration.
enum PluginErrorCode {
  GRAPHQL_ERROR
  INVALID
  PLUGIN_MISCONFIGURED
  NOT_FOUND
  REQUIRED
  UNIQUE
}

input PluginFilterInput {
  active: Boolean
  search: String
}

enum PluginSortField {
  NAME
  IS_ACTIVE
}

input PluginSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort plugins by the selected field.
  field: PluginSortField!
}

# Update plugin configuration.
type PluginUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  plugin: Plugin
  pluginsErrors: [PluginError!]!
}

input PluginUpdateInput {
  # Indicates whether the plugin should be enabled.
  active: Boolean
  # Configuration of the plugin.
  configuration: [ConfigurationItemInput]
}

# Positive Decimal scalar implementation
.
#
# Should be used in places where value must be positive.
scalar PositiveDecimal

input PriceRangeInput {
  # Price greater than or equal to.
  gte: Float
  # Price less than or equal to.
  lte: Float
}

# Represents an individual item for sale in the storefront.
type Product implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  seoTitle: String
  seoDescription: String
  name: String!
  descriptionJson: JSONString!
  publicationDate: Date
  productType: ProductType!
  slug: String!
  category: Category
  updatedAt: DateTime
  chargeTaxes: Boolean!
  weight: Weight
  availableForPurchase: Date
  visibleInListings: Boolean!
  defaultVariant: ProductVariant
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # The storefront URL for the product.
  url: String!
    @deprecated(reason: "This field will be removed after 2020-07-31.")
  # The main thumbnail for a product.
  thumbnail(
    # Size of thumbnail.
    size: Int
  ): Image
  # Lists the storefront product's pricing, the current price and discounts, only meant for displaying.
  pricing: ProductPricingInfo
  # Whether the product is in stock and visible or not.
  isAvailable: Boolean
  # The price of the cheapest variant (including discounts).
  minimalVariantPrice: Money
  # A type of tax. Assigned by enabled tax gateway
  taxType: TaxType
  # List of attributes assigned to this product.
  attributes: [SelectedAttribute!]!
  purchaseCost: MoneyRange
  margin: Margin
  # Get a single product image by ID.
  imageById(
    # ID of a product image.
    id: ID
  ): ProductImage
  # List of variants for the product.
  variants: [ProductVariant]
  # List of images for the product.
  images: [ProductImage]
  # List of collections for the product.
  collections: [Collection]
  # Returns translated product fields for the given language code.
  translation(
    # A language code to return the translation for product.
    languageCode: LanguageCodeEnum!
  ): ProductTranslation
  # Whether the product is available for purchase.
  isAvailableForPurchase: Boolean
  # Whether the product is published.
  isPublished: Boolean!
  # Description of the product.
  description: String!
    @deprecated(reason: "Use the `descriptionJson` field instead.")
}

# Deletes products.
type ProductBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Publish products.
type ProductBulkPublish {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Clears public metadata item for product.
type ProductClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  product: Product
}

# Clears private metadata item for product.
type ProductClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  product: Product
}

type ProductCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ProductCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ProductCountableEdge {
  # The item at the end of the edge.
  node: Product!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new product.
type ProductCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  product: Product
}

input ProductCreateInput {
  # List of attributes.
  attributes: [AttributeValueInput]
  # Publication date. ISO 8601 standard.
  publicationDate: Date
  # ID of the product's category.
  category: ID
  # Determine if taxes are being charged for the product.
  chargeTaxes: Boolean
  # List of IDs of collections that the product belongs to.
  collections: [ID]
  # Product description (HTML/text).
  description: String
  # Product description (JSON).
  descriptionJson: JSONString
  # Determines if product is visible to customers.
  isPublished: Boolean
  # Product name.
  name: String
  # Product slug.
  slug: String
  # Tax rate for enabled tax gateway.
  taxCode: String
  # Search engine optimization fields.
  seo: SeoInput
  # Weight of the Product.
  weight: WeightScalar
  # Stock keeping unit of a product. Note: this field is only used if a product doesn't use variants.
  sku: String
  # Determines if the inventory of this product should be tracked. If false, the
  # quantity won't change when customers buy this item. Note: this field is only
  # used if a product doesn't use variants.
  trackInventory: Boolean
  # Default price for product variant. Note: this field is only used if a product doesn't use variants.
  basePrice: PositiveDecimal
  # Determines if product is visible in product listings (doesn't apply to product collections).
  visibleInListings: Boolean
  # ID of the type that product belongs to.
  productType: ID!
  # Stocks of a product available for sale. Note: this field is only used if a product doesn't use variants.
  stocks: [StockInput!]
}

# Deletes a product.
type ProductDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  product: Product
}

# Duplicates a product.
type ProductDuplicate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The newly created product.
  product: Product
  productErrors: [ProductError!]!
}

type ProductError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ProductErrorCode!
  # List of attributes IDs which causes the error.
  attributes: [ID!]
}

# An enumeration.
enum ProductErrorCode {
  ALREADY_EXISTS
  ATTRIBUTE_ALREADY_ASSIGNED
  ATTRIBUTE_CANNOT_BE_ASSIGNED
  ATTRIBUTE_VARIANTS_DISABLED
  DUPLICATED_INPUT_ITEM
  GRAPHQL_ERROR
  INVALID
  NOT_PRODUCTS_IMAGE
  NOT_PRODUCTS_VARIANT
  NOT_FOUND
  REQUIRED
  UNIQUE
  VARIANT_NO_DIGITAL_CONTENT
}

enum ProductFieldEnum {
  NAME
  DESCRIPTION
  PRODUCT_TYPE
  CATEGORY
  VISIBLE
  AVAILABLE_FOR_PURCHASE
  SEARCHABLE
  PRODUCT_WEIGHT
  COLLECTIONS
  CHARGE_TAXES
  PRODUCT_IMAGES
  VARIANT_SKU
  VARIANT_PRICE
  COST_PRICE
  VARIANT_WEIGHT
  VARIANT_IMAGES
}

input ProductFilterInput {
  isPublished: Boolean
  collections: [ID]
  categories: [ID]
  hasCategory: Boolean
  attributes: [AttributeInput]
  stockAvailability: StockAvailability
  productType: ID
  stocks: ProductStockFilterInput
  search: String
  price: PriceRangeInput
  discount: IntRangeInput
  rating: IntRangeInput
  minimalPrice: PriceRangeInput
  productTypes: [ID]
  ids: [ID]
}

# Represents a product image.
type ProductImage implements Node {
  # The ID of the object.
  id: ID!
  sortOrder: Int
  alt: String!
  # The URL of the image.
  url(
    # Size of the image.
    size: Int
  ): String!
}

# Deletes product images.
type ProductImageBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Create a product image. This mutation must be sent as a `multipart` request.
# More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type ProductImageCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  product: Product
  image: ProductImage
  productErrors: [ProductError!]!
}

input ProductImageCreateInput {
  # Alt text for an image.
  alt: String
  # Represents an image file in a multipart request.
  image: Upload!
  # ID of an product.
  product: ID!
}

# Create a product image. This mutation must be sent as a `multipart` request.
# More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type ProductImageCreateV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  product: Product
  image: ProductImage
  productErrors: [ProductError!]!
}

# Deletes a product image.
type ProductImageDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  product: Product
  image: ProductImage
  productErrors: [ProductError!]!
}

# Changes ordering of the product image.
type ProductImageReorder {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  product: Product
  images: [ProductImage]
  productErrors: [ProductError!]!
}

# Updates a product image.
type ProductImageUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  product: Product
  image: ProductImage
  productErrors: [ProductError!]!
}

input ProductImageUpdateInput {
  # Alt text for an image.
  alt: String
}

input ProductInput {
  # List of attributes.
  attributes: [AttributeValueInput]
  # Publication date. ISO 8601 standard.
  publicationDate: Date
  # ID of the product's category.
  category: ID
  # Determine if taxes are being charged for the product.
  chargeTaxes: Boolean
  # List of IDs of collections that the product belongs to.
  collections: [ID]
  # Product description (HTML/text).
  description: String
  # Product description (JSON).
  descriptionJson: JSONString
  # Determines if product is visible to customers.
  isPublished: Boolean
  # Product name.
  name: String
  # Product slug.
  slug: String
  # Tax rate for enabled tax gateway.
  taxCode: String
  # Search engine optimization fields.
  seo: SeoInput
  # Weight of the Product.
  weight: WeightScalar
  # Stock keeping unit of a product. Note: this field is only used if a product doesn't use variants.
  sku: String
  # Determines if the inventory of this product should be tracked. If false, the
  # quantity won't change when customers buy this item. Note: this field is only
  # used if a product doesn't use variants.
  trackInventory: Boolean
  # Default price for product variant. Note: this field is only used if a product doesn't use variants.
  basePrice: PositiveDecimal
  # Determines if product is visible in product listings (doesn't apply to product collections).
  visibleInListings: Boolean
}

input ProductOrder {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort product by the selected attribute's values.
  # Note: this doesn't take translations into account yet.
  attributeId: ID
  # Sort products by the selected field.
  field: ProductOrderField
}

enum ProductOrderField {
  # Sort products by name.
  NAME
  # Sort products by price.
  PRICE
  # Sort products by a minimal price of a product's variant.
  MINIMAL_PRICE
  # Sort products by update date.
  DATE
  # Sort products by type.
  TYPE
  # Sort products by publication status.
  PUBLISHED
  # Sort products by publication date.
  PUBLICATION_DATE
  # Sort products by collection. Note: This option is available only for the `Collection.products` query.
  COLLECTION
}

# Represents availability of a product in the storefront.
type ProductPricingInfo {
  # Whether it is in sale or not.
  onSale: Boolean
  # The discount amount if in sale (null otherwise).
  discount: TaxedMoney
  # The discount amount in the local currency.
  discountLocalCurrency: TaxedMoney
  # The discounted price range of the product variants.
  priceRange: TaxedMoneyRange
  # The undiscounted price range of the product variants.
  priceRangeUndiscounted: TaxedMoneyRange
  # The discounted price range of the product variants in the local currency.
  priceRangeLocalCurrency: TaxedMoneyRange
}

# Create a product_review image. This mutation must be sent as a `multipart`
# request. More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type ProductReviewImageCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productReview: ProductReviewType
  image: ProductReviewImageType
  productErrors: [ProductError!]!
}

input ProductReviewImageCreateInput {
  # Alt text for an image.
  alt: String
  # Represents an image file in a multipart request.
  image: Upload!
  # ID of a product_review
  productReview: ID!
}

# Deletes a product_review image.
type ProductReviewImageDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Delete Images from product_review.
  productReview: ProductReviewType
  image: ProductReviewImageType
  productErrors: [ProductError!]!
}

type ProductReviewImageType implements Node {
  sortOrder: Int
  # The ID of the object.
  id: ID!
  productReview: ProductReviewType!
  image: String!
  ppoi: String!
  alt: String!
  # The URL of the image.
  url(
    # Size of the image.
    size: Int
  ): String!
}

type ProductReviewImageTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [ProductReviewImageTypeEdge]!
}

# A Relay edge containing a `ProductReviewImageType` and its cursor.
type ProductReviewImageTypeEdge {
  # The item at the end of the edge
  node: ProductReviewImageType
  # A cursor for use in pagination
  cursor: String!
}

input ProductReviewInput {
  # Product Id
  productId: ID
  # Name of the user
  userName: String
  # User review on the product
  review: String
  # User rating for the product
  rating: Int!
  # Toggle view for the review
  isPublished: Boolean
}

type ProductReviewType implements Node {
  # The ID of the object.
  id: ID!
  user: User
  userName: String
  product: Product!
  review: String!
  rating: Int!
  isPublished: Boolean!
  externalReviewId: String
  created: DateTime!
  updated: DateTime!
  sortOrder: Int
  images(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
  ): ProductReviewImageTypeConnection!
  videos(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
  ): ProductReviewVideoTypeConnection!
}

type ProductReviewTypeCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ProductReviewTypeCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ProductReviewTypeCountableEdge {
  # The item at the end of the edge.
  node: ProductReviewType!
  # A cursor for use in pagination.
  cursor: String!
}

# Create a product_review video. This mutation must be sent as a `multipart`
# request. More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type ProductReviewVideoCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productReview: ProductReviewType
  video: ProductReviewVideoType
  productErrors: [ProductError!]!
}

input ProductReviewVideoCreateInput {
  # Alt text for an video.
  alt: String
  # Represents an video file in a multipart request.
  video: Upload!
  # ID of a product_review
  productReview: ID!
}

# Deletes a product_review video.
type ProductReviewVideoDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Delete Video from product_review.
  productReview: ProductReviewType
  video: ProductReviewVideoType
  productErrors: [ProductError!]!
}

type ProductReviewVideoType implements Node {
  sortOrder: Int
  # The ID of the object.
  id: ID!
  productReview: ProductReviewType!
  video: String!
  alt: String!
  # The URL of the video.
  url(
    # Size of the video.
    size: Int
  ): String!
}

type ProductReviewVideoTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [ProductReviewVideoTypeEdge]!
}

# A Relay edge containing a `ProductReviewVideoType` and its cursor.
type ProductReviewVideoTypeEdge {
  # The item at the end of the edge
  node: ProductReviewVideoType
  # A cursor for use in pagination
  cursor: String!
}

# Set product availability for purchase date.
type ProductSetAvailabilityForPurchase {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  product: Product
  productErrors: [ProductError!]!
}

input ProductStockFilterInput {
  warehouseIds: [ID!]
  quantity: IntRangeInput
}

type ProductTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  seoTitle: String
  seoDescription: String
  name: String!
  descriptionJson: JSONString!
  # Description of the product.
  description: String!
    @deprecated(reason: "Use the `descriptionJson` field instead.")
  # Returns translated product fields for the given language code.
  translation(
    # A language code to return the translation for product.
    languageCode: LanguageCodeEnum!
  ): ProductTranslation
  # Represents an individual item for sale in the storefront.
  product: Product
}

# Creates/Updates translations for Product.
type ProductTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  product: Product
}

type ProductTranslation implements Node {
  # The ID of the object.
  id: ID!
  seoTitle: String
  seoDescription: String
  name: String!
  descriptionJson: JSONString!
  # Translation language.
  language: LanguageDisplay!
  # Translated description of the product.
  description: String!
    @deprecated(reason: "Use the `descriptionJson` field instead.")
}

# Represents a type of product. It defines what attributes are available to products of this type.
type ProductType implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  name: String!
  slug: String!
  hasVariants: Boolean!
  isShippingRequired: Boolean!
  isDigital: Boolean!
  weight: Weight
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # List of products of this type.
  products(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductCountableConnection
  # A type of tax rate.
  taxRate: TaxRateType
    @deprecated(
      reason: "Use the TaxType instead. It will be removed in Saleor 3.0."
    )
  # A type of tax. Assigned by enabled tax gateway
  taxType: TaxType
  # Variant attributes of that product type.
  variantAttributes: [Attribute]
  # Product attributes of that product type.
  productAttributes: [Attribute]
  availableAttributes(
    filter: AttributeFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): AttributeCountableConnection
}

# Deletes product types.
type ProductTypeBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Clears public metadata for product type.
type ProductTypeClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productType: ProductType
}

# Clears private metadata for product type.
type ProductTypeClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productType: ProductType
}

enum ProductTypeConfigurable {
  CONFIGURABLE
  SIMPLE
}

type ProductTypeCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ProductTypeCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ProductTypeCountableEdge {
  # The item at the end of the edge.
  node: ProductType!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new product type.
type ProductTypeCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productType: ProductType
}

# Deletes a product type.
type ProductTypeDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productType: ProductType
}

enum ProductTypeEnum {
  DIGITAL
  SHIPPABLE
}

input ProductTypeFilterInput {
  search: String
  configurable: ProductTypeConfigurable
  productType: ProductTypeEnum
  ids: [ID]
}

input ProductTypeInput {
  # Name of the product type.
  name: String
  # Product type slug.
  slug: String
  # Determines if product of this type has multiple variants. This option mainly
  # simplifies product management in the dashboard. There is always at least one
  # variant created under the hood.
  hasVariants: Boolean
  # List of attributes shared among all product variants.
  productAttributes: [ID]
  # List of attributes used to distinguish between different variants of a product.
  variantAttributes: [ID]
  # Determines if shipping is required for products of this variant.
  isShippingRequired: Boolean
  # Determines if products are digital.
  isDigital: Boolean
  # Weight of the ProductType items.
  weight: WeightScalar
  # Tax rate for enabled tax gateway.
  taxCode: String
}

# Reorder the attributes of a product type.
type ProductTypeReorderAttributes {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Product type from which attributes are reordered.
  productType: ProductType
  productErrors: [ProductError!]!
}

enum ProductTypeSortField {
  # Sort products by name.
  NAME
  # Sort products by type.
  DIGITAL
  # Sort products by shipping.
  SHIPPING_REQUIRED
}

input ProductTypeSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort product types by the selected field.
  field: ProductTypeSortField!
}

# Updates an existing product type.
type ProductTypeUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productType: ProductType
}

# Update public metadata for product type.
type ProductTypeUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productType: ProductType
}

# Update private metadata for product type.
type ProductTypeUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productType: ProductType
}

# Updates an existing product.
type ProductUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  product: Product
}

# Update public metadata for product.
type ProductUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  product: Product
}

# Update private metadata for product.
type ProductUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  product: Product
}

# Represents a version of a product such as different size or color.
type ProductVariant implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  name: String!
  sku: String!
  product: Product!
  trackInventory: Boolean!
  weight: Weight
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # Quantity of a product available for sale.
  quantity: Int!
    @deprecated(
      reason: "Use the stock field instead. This field will be removed after 2020-07-31."
    )
  # Quantity allocated for orders.
  quantityAllocated: Int
    @deprecated(
      reason: "Use the stock field instead. This field will be removed after 2020-07-31."
    )
  # Quantity of a product available for sale.
  stockQuantity: Int!
    @deprecated(
      reason: "Use the quantityAvailable field instead. This field will be removed after 2020-07-31."
    )
  # Base price of a product variant. This field is restricted for admins. Use the
  # pricing field to get the public price for customers.
  price: Money
  # Lists the storefront variant's pricing, the current price and discounts, only meant for displaying.
  pricing: VariantPricingInfo
  # Whether the variant is in stock and visible or not.
  isAvailable: Boolean
    @deprecated(
      reason: "Use the stock field instead. This field will be removed after 2020-07-31."
    )
  # List of attributes assigned to this variant.
  attributes: [SelectedAttribute!]!
  # Cost price of the variant.
  costPrice: Money
  # Gross margin percentage value.
  margin: Int
  # Total quantity ordered.
  quantityOrdered: Int
  # Total revenue generated by a variant in given period of time. Note: this field
  # should be queried using `reportProductSales` query as it uses optimizations
  # suitable for such calculations.
  revenue(period: ReportingPeriod): TaxedMoney
  # List of images for the product variant.
  images: [ProductImage]
  # Returns translated product variant fields for the given language code.
  translation(
    # A language code to return the translation for product variant.
    languageCode: LanguageCodeEnum!
  ): ProductVariantTranslation
  # Digital content for the product variant.
  digitalContent: DigitalContent
  # Stocks for the product variant.
  stocks(
    # Two-letter ISO 3166-1 country code.
    countryCode: CountryCode
  ): [Stock]
  # Quantity of a product available for sale in one checkout.
  quantityAvailable(
    # Two-letter ISO 3166-1 country code. When provided, the exact quantity from a
    # warehouse operating in shipping zones that contain this country will be
    # returned. Otherwise, it will return the maximum quantity from all shipping zones.
    countryCode: CountryCode
  ): Int!
}

# Creates product variants for a given product.
type ProductVariantBulkCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were created.
  count: Int!
  # List of the created variants.
  productVariants: [ProductVariant!]!
  bulkProductErrors: [BulkProductError!]!
}

input ProductVariantBulkCreateInput {
  # List of attributes specific to this variant.
  attributes: [AttributeValueInput]!
  # Cost price of the variant.
  costPrice: PositiveDecimal
  # Price of the particular variant.
  price: PositiveDecimal
  # Stock keeping unit.
  sku: String!
  # Determines if the inventory of this variant should be tracked. If false, the
  # quantity won't change when customers buy this item.
  trackInventory: Boolean
  # Weight of the Product Variant.
  weight: WeightScalar
  # Stocks of a product available for sale.
  stocks: [StockInput!]
}

# Deletes product variants.
type ProductVariantBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Updates a list ProductVariant quantities
type ProductVariantBulkUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A list of updated quantities of respective productVariants
  productVariants: [ProductVariant]
}

# Clears public metadata for product variant.
type ProductVariantClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productVariant: ProductVariant
}

# Clears private metadata for product variant.
type ProductVariantClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productVariant: ProductVariant
}

type ProductVariantCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ProductVariantCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ProductVariantCountableEdge {
  # The item at the end of the edge.
  node: ProductVariant!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new variant for a product.
type ProductVariantCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productVariant: ProductVariant
}

input ProductVariantCreateInput {
  # List of attributes specific to this variant.
  attributes: [AttributeValueInput]!
  # Cost price of the variant.
  costPrice: PositiveDecimal
  # Price of the particular variant.
  price: PositiveDecimal
  # Stock keeping unit.
  sku: String
  # Determines if the inventory of this variant should be tracked. If false, the
  # quantity won't change when customers buy this item.
  trackInventory: Boolean
  # Weight of the Product Variant.
  weight: WeightScalar
  # Product ID of which type is the variant.
  product: ID!
  # Stocks of a product available for sale.
  stocks: [StockInput!]
}

# Deletes a product variant.
type ProductVariantDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productVariant: ProductVariant
}

input ProductVariantFilterInput {
  search: String
  sku: [String]
}

input ProductVariantInput {
  # List of attributes specific to this variant.
  attributes: [AttributeValueInput]
  # Cost price of the variant.
  costPrice: PositiveDecimal
  # Price of the particular variant.
  price: PositiveDecimal
  # Stock keeping unit.
  sku: String
  # Determines if the inventory of this variant should be tracked. If false, the
  # quantity won't change when customers buy this item.
  trackInventory: Boolean
  # Weight of the Product Variant.
  weight: WeightScalar
}

# Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook.
type ProductVariantReorder {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  product: Product
  productErrors: [ProductError!]!
}

# Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook.
type ProductVariantSetDefault {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  product: Product
  productErrors: [ProductError!]!
}

# Creates stocks for product variant.
type ProductVariantStocksCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated product variant.
  productVariant: ProductVariant
  bulkStockErrors: [BulkStockError!]!
}

# Delete stocks from product variant.
type ProductVariantStocksDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated product variant.
  productVariant: ProductVariant
  stockErrors: [StockError!]!
}

# Update stocks for product variant.
type ProductVariantStocksUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated product variant.
  productVariant: ProductVariant
  bulkStockErrors: [BulkStockError!]!
}

type ProductVariantTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Returns translated product variant fields for the given language code.
  translation(
    # A language code to return the translation for product variant.
    languageCode: LanguageCodeEnum!
  ): ProductVariantTranslation
  # Represents a version of a product such as different size or color.
  productVariant: ProductVariant
}

# Creates/Updates translations for Product Variant.
type ProductVariantTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  productVariant: ProductVariant
}

type ProductVariantTranslation implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Translation language.
  language: LanguageDisplay!
}

# Updates an existing variant for product.
type ProductVariantUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productVariant: ProductVariant
}

# Update public metadata for product variant.
type ProductVariantUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productVariant: ProductVariant
}

# Update private metadata for product variant.
type ProductVariantUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productErrors: [ProductError!]!
  productVariant: ProductVariant
}

# Push or sync all unsynced orders to wareiq
type PushAllToWareIq {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # List of pushed orders.
  pushedOrders: [Order]
  # List of pushed orders.
  failedOrders: [Order]
  orderErrors: [OrderError!]!
}

# Push or sync an order to wareiq
type PushToWareIq {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated order instance.
  order: Order
  # Action that occured. (push/sync)
  action: String
  orderErrors: [OrderError!]!
}

type Query {
  gokwikRtoPredict(
    # checkout id
    checkoutId: String
  ): GokwikType
  deliverySchedule(
    before: String
    after: String
    first: Int
    last: Int
    warehouse: String
  ): DeliverySchedulerTypeConnection
  # List of the Delivery Schedules.
  deliverySchedules(
    # The warehouse's name.
    warehouse: String
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): DeliverySchedulerTypeConnection
  emailValidator(
    # email to be validated.
    email: String
  ): EmailValidatorType
  hostings(
    # Sort files.
    sortBy: HostingOrder
    before: String
    after: String
    first: Int
    last: Int
    name: String
    id: ID
  ): HostingTypeConnection
  # Look up a navigation menuV2 by ID or name.
  menuV2(
    # ID of the menu.
    id: ID
    # The menu's name.
    name: String
    # The menu's slug.
    slug: String
  ): MenuV2
  # List of the storefront's menus.
  menusV2(
    # Sort menus.
    sortBy: MenuSortingInput
    # Filtering options for menus.
    filter: MenuFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): MenuV2CountableConnection
  # Look up a menu item by ID.
  menuItemV2(
    # ID of the menu item.
    id: ID!
  ): MenuItemV2
  # List of the storefronts's menu items.
  menuItemsV2(
    # Sort menus items.
    sortBy: MenuItemSortingInput
    # Filtering options for menu items.
    filter: MenuItemFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): MenuItemV2CountableConnection
  shipment(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    shipmentId: String
    orderId: ID
  ): ShipmentTypeConnection
  # List of the Shipments.
  shipments(
    # Filter shipments by shopify store id
    shopifyStoreId: String
    # Filter shipments by shopify order id
    shopifyOrderId: String
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ShipmentTypeConnection
  dtcTracking(
    # order id to get tracking data
    orderId: String
    # order id to get tracking data
    awb: String
  ): DtcTrackingType
  # List of cancel reasons
  dtcCancelReason: [String]
  # List of return reasons
  dtcReturnReason: [String]
  dtcReturnProduct(
    # order id to get return product
    orderId: String
    # customer id
    customerId: String
  ): DtcReturnProductType
  dtcEligibleForCancelOrReturn(
    # order numbers
    orderNumbers: [String]
    # customer id
    customerId: String
  ): DtcEligibleType
  searchWithSearchtap(
    # Search Term.
    searchTerm: String
    # Fields to search from Searchtap.
    input: SearchtapInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductCountableConnection
  shopmeta(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    name: String
  ): ShopMetaTypeConnection
  users(phone: String, email: String): User
  section(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    name: String
    isPublished: Boolean
  ): SectionTypeCountableConnection
  # List of the shop's sections.
  sections(
    # Filtering options for sections.
    filter: SectionFilterInput
    # Filter sections by the nesting level in the category tree.
    level: Int
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): SectionTypeCountableConnection
  shopifyUserOrders(
    # User Id of the user.
    userId: ID
    # paginates with first given orders
    first: Int
    # paginates after given orders
    after: Int
    # id of the single order.
    orderId: ID
  ): [ShopifyOrderType]
  shopifyGiftCard(giftCard: String): ShopifyGiftCardType
  shopifyUser(
    # User Id of the user.
    userId: ID
    # unique hash of user.
    userHash: String
  ): [ShopifyUserType]
  influencer(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    name: String
    phone: String
    email: String
  ): InfluencerTypeConnection
  subscriptions(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    product: ID
    user: ID
  ): SubscriptionTypeConnection
  # Look up a Survey by ID.
  surveyFill(
    # ID of Survey instance.
    id: ID
    # Survey unique hash.
    surveyHash: String
  ): SurveyFillType
  surveys(
    before: String
    after: String
    first: Int
    last: Int
    name: String
    shown: Boolean
    attempted: Boolean
    created: DateTime
  ): SurveyTypeConnection
  # Look up a Survey by ID.
  survey(
    # ID of Survey.
    id: ID
  ): SurveyType
  combos(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    variant: ID
    variants: [ID]
  ): ComboTypeConnection
  pincodes(
    before: String
    after: String
    first: Int
    last: Int
    pin: String
    city: String
    state: String
    serviceable: Boolean
    created: DateTime
    updated: DateTime
  ): PincodeTypeConnection
  pincode(
    # The pincode.
    pin: String
  ): PincodeType
  contactUs(
    # Id of the contact us form.
    id: ID
    # Search term to find a contact us by name, email or phone.
    search: String
    # Sort contact us by name or date.
    sortBy: ContactUsOrder
    before: String
    after: String
    first: Int
    last: Int
    queryType: String
    email: String
    name: String
    name_Icontains: String
    name_Istartswith: String
    phone: String
    createdAt: DateTime
    createdAt_Lte: DateTime
    createdAt_Gte: DateTime
  ): ContactUsTypeConnection
  filterCheckouts(
    # Start date for filter.
    start: DateTime
    # End date for filter.
    end: DateTime
    # User Id of the checkout user.
    user: ID
    # Email of customer.
    email: String
    # Phone no as set in the billing address.
    phone: String
    # Quantity Greater than equals.
    quantityGte: Int
    # Not Equals to Email of Customer.
    emailNe: String
    # Token of the Payments.
    paymentsToken: String
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CheckoutTypeCountableConnection
  wallet(
    # User Id of the wallet owner.
    userId: ID
  ): WalletType
  partnerCouponCustomers(
    before: String
    after: String
    first: Int
    last: Int
    partner: ID
    code: String
    name: String
  ): PartnerCouponCustomerTypeConnection
  # Look up a Partner Coupon by ID.
  partnerCouponCustomer(
    # Partner Coupon ID.
    id: ID
  ): PartnerCouponCustomerType
  partnerCoupons(
    before: String
    after: String
    first: Int
    last: Int
    partner: ID
    code: String
    name: String
  ): PartnerCouponTypeConnection
  # Look up a Partner Coupon by ID.
  partnerCoupon(
    # Partner Coupon ID.
    id: ID
  ): PartnerCouponType
  partners(
    before: String
    after: String
    first: Int
    last: Int
    name: String
    minSpentAmount: Float
  ): PartnerTypeConnection
  # Look up a Partner by ID.
  partner(
    # Partner ID.
    id: ID
  ): PartnerType
  orderStatus(
    # The Order's token.
    token: UUID
  ): CustomOrderStatus
  deliveryDate(
    # Order ID
    orderId: ID
  ): JSONString
  exportOrders(
    # field instead. This field will be removed after 2020-07-31.
    start: DateTime
    # field instead. This field will be removed after 2020-07-31.
    end: DateTime
    # field instead. This field will be removed after 2020-07-31.
    wareiqStatus: String
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): OrderCountableConnection
  # Return the total sales amount from a specific period.
  ordersTotalv2(
    # A period of time.
    period: ReportingPeriodV2
  ): TaxedMoney
  # List of orders and their count.
  ordersV2(
    # Sort orders.
    sortBy: OrderSortingInput
    # Filtering options for orders.
    filter: OrderFilterInput
    # [Deprecated] Filter orders from a selected timespan. Use the `filter` field
    # instead. This field will be removed after 2020-07-31.
    created: ReportingPeriodV2
    # [Deprecated] Filter order by status. Use the `filter` field instead. This field will be removed after 2020-07-31.
    status: OrderStatusFilter
    # A period of time.
    period: ReportingPeriodV2
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): OrderCountableConnection
  addressType(
    # The checkout's token.
    addressId: ID!
  ): AddressLinkType
  checkoutDiscounts(
    # The checkout's token.
    token: UUID
  ): DiscountsType
  cashback(
    # The checkout's token.
    checkoutToken: UUID
    # The order's token.
    orderToken: UUID
  ): CashbackType
  voucherRule(
    # Filtering options for voucher rules.
    filter: VoucherRuleFilterInput
    # Sort products.
    sortBy: VoucherRuleOrder
    # Id of rule
    id: ID
    # Type of offer
    discountType: DiscountType
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): VoucherRuleTypeConnection
  voucherRuleLink(
    before: String
    after: String
    first: Int
    last: Int
    code: String
    isEnabled: Boolean
    rule: ID
    id: ID
  ): VoucherRuleLinkTypeConnection
  couponDiscount(
    # The checkout's token.
    token: UUID
  ): CouponDiscountType
  productOffers(
    # Id of the product.
    productId: ID
  ): [String]
  freeCheckoutLines(token: String): [CheckoutLine]
  headers(
    before: String
    after: String
    first: Int
    last: Int
    text: String
    name: String
    created: DateTime
    # Ordering
    orderBy: String
  ): HeaderTypeConnection
  wishlist: Wishlist
  banners(
    before: String
    after: String
    first: Int
    last: Int
    name: String
    isEnabled: Boolean
    id: ID
    type: String
    link: String
    position: Int
  ): CustomBannerTypeConnection
  productReviews(
    # Product ID
    product: ID!
    # Product Review ID
    id: ID
    # User ID
    user: String
    # Is Published
    isPublished: Boolean
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductReviewTypeCountableConnection
  # Look up a webhook by ID.
  webhook(
    # ID of the webhook.
    id: ID!
  ): Webhook
  # List of webhooks.
  webhooks(
    # Sort webhooks.
    sortBy: WebhookSortingInput
    # Filtering options for webhooks.
    filter: WebhookFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): WebhookCountableConnection
    @deprecated(
      reason: "Use webhooks field on app(s) query instead. This field will be removed after 2020-07-31."
    )
  # List of all available webhook events.
  webhookEvents: [WebhookEvent]
  # Retrieve a sample payload for a given webhook event based on real data. It can
  # be useful for some integrations where sample payload is required.
  webhookSamplePayload(
    # Name of the requested event type.
    eventType: WebhookSampleEventTypeEnum!
  ): JSONString
  # Look up a warehouse by ID.
  warehouse(
    # ID of an warehouse
    id: ID!
  ): Warehouse
  # List of warehouses.
  warehouses(
    filter: WarehouseFilterInput
    sortBy: WarehouseSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): WarehouseCountableConnection
  # Returns a list of all translatable items of a given kind.
  translations(
    # Kind of objects to retrieve.
    kind: TranslatableKinds!
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): TranslatableItemConnection
  translation(
    # ID of the object to retrieve.
    id: ID!
    # Kind of the object to retrieve.
    kind: TranslatableKinds!
  ): TranslatableItem
  # Look up a stock by ID
  stock(
    # ID of an warehouse
    id: ID!
  ): Stock
  # List of stocks.
  stocks(
    filter: StockFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): StockCountableConnection
  # Return information about the shop.
  shop: Shop!
  # Look up a shipping zone by ID.
  shippingZone(
    # ID of the shipping zone.
    id: ID!
  ): ShippingZone
  # List of the shop's shipping zones.
  shippingZones(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ShippingZoneCountableConnection
  # Look up digital content by ID.
  digitalContent(
    # ID of the digital content.
    id: ID!
  ): DigitalContent
  # List of digital content.
  digitalContents(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): DigitalContentCountableConnection
  # List of the shop's attributes.
  attributes(
    # Filtering options for attributes.
    filter: AttributeFilterInput
    # Sorting options for attributes.
    sortBy: AttributeSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): AttributeCountableConnection
  # Look up an attribute by ID.
  attribute(
    # ID of the attribute.
    id: ID!
  ): Attribute
  # List of the shop's categories.
  categories(
    # Filtering options for categories.
    filter: CategoryFilterInput
    # Sort categories.
    sortBy: CategorySortingInput
    # Filter categories by the nesting level in the category tree.
    level: Int
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CategoryCountableConnection
  # Look up a category by ID or slug.
  category(
    # ID of the category.
    id: ID
    # Slug of the category
    slug: String
  ): Category
  # Look up a collection by ID.
  collection(
    # ID of the collection.
    id: ID
    # Slug of the category
    slug: String
  ): Collection
  # List of the shop's collections.
  collections(
    # Filtering options for collections.
    filter: CollectionFilterInput
    # Sort collections.
    sortBy: CollectionSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CollectionCountableConnection
  # Look up a product by ID.
  product(
    # ID of the product.
    id: ID
    # Slug of the category
    slug: String
  ): Product
  # List of the shop's products.
  products(
    # Filtering options for products.
    filter: ProductFilterInput
    # Sort products.
    sortBy: ProductOrder
    # [Deprecated] Filter products by stock availability. Use the `filter` field
    # instead. This field will be removed after 2020-07-31.
    stockAvailability: StockAvailability
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductCountableConnection
  # Look up a product type by ID.
  productType(
    # ID of the product type.
    id: ID!
  ): ProductType
  # List of the shop's product types.
  productTypes(
    # Filtering options for product types.
    filter: ProductTypeFilterInput
    # Sort product types.
    sortBy: ProductTypeSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductTypeCountableConnection
  # Look up a product variant by ID or SKU.
  productVariant(
    # ID of the product variant.
    id: ID
    # Sku of the product variant.
    sku: String
  ): ProductVariant
  # List of product variants.
  productVariants(
    # Filter product variants by given IDs.
    ids: [ID]
    # Filtering options for product variant.
    filter: ProductVariantFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductVariantCountableConnection
  # List of top selling products.
  reportProductSales(
    # Span of time.
    period: ReportingPeriod!
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductVariantCountableConnection
  # Look up a payment by ID.
  payment(
    # ID of the payment.
    id: ID!
  ): Payment
  # List of payments.
  payments(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): PaymentCountableConnection
  # Look up a page by ID or slug.
  page(
    # ID of the page.
    id: ID
    # The slug of the page.
    slug: String
  ): Page
  # List of the shop's pages.
  pages(
    # Sort pages.
    sortBy: PageSortingInput
    # Filtering options for pages.
    filter: PageFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): PageCountableConnection
  # List of activity events to display on homepage (at the moment it only contains order-events).
  homepageEvents(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): OrderEventCountableConnection
  # Look up an order by ID.
  order(
    # ID of an order.
    id: ID!
  ): Order
  # List of orders.
  orders(
    # Sort orders.
    sortBy: OrderSortingInput
    # Filtering options for orders.
    filter: OrderFilterInput
    # [Deprecated] Filter orders from a selected timespan. Use the `filter` field
    # instead. This field will be removed after 2020-07-31.
    created: ReportingPeriod
    # [Deprecated] Filter order by status. Use the `filter` field instead. This field will be removed after 2020-07-31.
    status: OrderStatusFilter
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): OrderCountableConnection
  # List of draft orders.
  draftOrders(
    # Sort draft orders.
    sortBy: OrderSortingInput
    # Filtering options for draft orders.
    filter: OrderDraftFilterInput
    # [Deprecated] Filter draft orders from a selected timespan. Use the `filter`
    # field instead. This field will be removed after 2020-07-31.
    created: ReportingPeriod
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): OrderCountableConnection
  # Return the total sales amount from a specific period.
  ordersTotal(
    # A period of time.
    period: ReportingPeriod
  ): TaxedMoney
  # Look up an order by token.
  orderByToken(
    # The order's token.
    token: UUID!
  ): Order
  # Look up a navigation menu by ID or name.
  menu(
    # ID of the menu.
    id: ID
    # The menu's name.
    name: String
    # The menu's slug.
    slug: String
  ): Menu
  # List of the storefront's menus.
  menus(
    # Sort menus.
    sortBy: MenuSortingInput
    # Filtering options for menus.
    filter: MenuFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): MenuCountableConnection
  # Look up a menu item by ID.
  menuItem(
    # ID of the menu item.
    id: ID!
  ): MenuItem
  # List of the storefronts's menu items.
  menuItems(
    # Sort menus items.
    sortBy: MenuItemSortingInput
    # Filtering options for menu items.
    filter: MenuItemFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): MenuItemCountableConnection
  # Look up a gift card by ID.
  giftCard(
    # ID of the gift card.
    id: ID!
  ): GiftCard
  # List of gift cards.
  giftCards(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): GiftCardCountableConnection
  # Look up a plugin by ID.
  plugin(
    # ID of the plugin.
    id: ID!
  ): Plugin
  # List of plugins.
  plugins(
    # Filtering options for plugins.
    filter: PluginFilterInput
    # Sort plugins.
    sortBy: PluginSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): PluginCountableConnection
  # Look up a sale by ID.
  sale(
    # ID of the sale.
    id: ID!
  ): Sale
  # List of the shop's sales.
  sales(
    # Filtering options for sales.
    filter: SaleFilterInput
    # Sort sales.
    sortBy: SaleSortingInput
    # Search sales by name, value or type.
    query: String
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): SaleCountableConnection
  # Look up a voucher by ID.
  voucher(
    # ID of the voucher.
    id: ID!
  ): Voucher
  # List of the shop's vouchers.
  vouchers(
    # Filtering options for vouchers.
    filter: VoucherFilterInput
    # Sort voucher.
    sortBy: VoucherSortingInput
    # Search vouchers by name or code.
    query: String
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): VoucherCountableConnection
  # Look up a export file by ID.
  exportFile(
    # ID of the export file job.
    id: ID!
  ): ExportFile
  # List of export files.
  exportFiles(
    # Filtering options for export files.
    filter: ExportFileFilterInput
    # Sort export files.
    sortBy: ExportFileSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ExportFileCountableConnection
  # List of all tax rates available from tax gateway.
  taxTypes: [TaxType]
  # Look up a checkout by token.
  checkout(
    # The checkout's token.
    token: UUID
  ): Checkout
  # List of checkouts.
  checkouts(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CheckoutCountableConnection
  # Look up a checkout line by ID.
  checkoutLine(
    # ID of the checkout line.
    id: ID
  ): CheckoutLine
  # List of checkout lines.
  checkoutLines(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CheckoutLineCountableConnection
  # List of all apps installations
  appsInstallations: [AppInstallation!]!
  # List of the apps.
  apps(
    # Filtering options for apps.
    filter: AppFilterInput
    # Sort apps.
    sortBy: AppSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): AppCountableConnection
  # Look up a app by ID.
  app(
    # ID of the app.
    id: ID!
  ): App
  # Returns address validation rules.
  addressValidationRules(
    # Two-letter ISO 3166-1 country code.
    countryCode: CountryCode!
    # Designation of a region, province or state.
    countryArea: String
    # City or a town name.
    city: String
    # Sublocality like a district.
    cityArea: String
  ): AddressValidationData
  # Look up an address by ID.
  address(
    # ID of an address.
    id: ID!
  ): Address
  # List of the shop's customers.
  customers(
    # Filtering options for customers.
    filter: CustomerFilterInput
    # Sort customers.
    sortBy: UserSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): UserCountableConnection
  # List of permission groups.
  permissionGroups(
    # Filtering options for permission groups.
    filter: PermissionGroupFilterInput
    # Sort permission groups.
    sortBy: PermissionGroupSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): GroupCountableConnection
  # Look up permission group by ID.
  permissionGroup(
    # ID of the group.
    id: ID!
  ): Group
  # Return the currently authenticated user.
  me: User
  # List of the shop's staff users.
  staffUsers(
    # Filtering options for staff users.
    filter: StaffUserInput
    # Sort staff users.
    sortBy: UserSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): UserCountableConnection
  # List of the service accounts.
  serviceAccounts(
    # Filtering options for service accounts.
    filter: ServiceAccountFilterInput
    # Sort service accounts.
    sortBy: ServiceAccountSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ServiceAccountCountableConnection
    @deprecated(
      reason: "Use the `apps` query instead. This field will be removed after 2020-07-31."
    )
  # Look up a service account by ID.
  serviceAccount(
    # ID of the service account.
    id: ID!
  ): ServiceAccount
    @deprecated(
      reason: "Use the `app` query instead. This field will be removed after 2020-07-31."
    )
  # Look up a user by ID.
  user(
    # ID of the user.
    id: ID!
  ): User
  _entities(representations: [_Any]): [_Entity]
  _service: _Service
}

input RazorpayCreateOrderInput {
  # Checkout ID.
  checkoutId: ID!
}

type RazorpayError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: RazorpayErrorCodeEnum
}

# An enumeration.
enum RazorpayErrorCodeEnum {
  INVALID_AMOUNT
  INVALID_CURRENCY
  INVALID
}

type RazorpayOrderType {
  # Razorpay Order ID.
  id: String
  # Total order amount.
  amount: Decimal
  # Amount paid for the order.
  amountPaid: Decimal
  # Amount due for the order.
  amountDue: Decimal
  # Amount currency.
  currency: String
  # Order status.
  status: String
  # Order creation timestamp.
  createdAt: Int
}

# Represents a reduced VAT rate for a particular type of goods.
type ReducedRate {
  # Reduced VAT rate in percent.
  rate: Float!
  # A type of goods.
  rateType: TaxRateType!
}

# Refresh JWT token. Mutation tries to take refreshToken from the input.If it
# fails it will try to take refreshToken from the http-only cookie -refreshToken.
# csrfToken is required when refreshToken is provided as a cookie.
type RefreshToken {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # JWT token, required to authenticate.
  token: String
  # A user instance.
  user: User
  accountErrors: [AccountError!]!
}

input ReorderInput {
  # The ID of the item to move.
  id: ID!
  # The new relative sorting position of the item (from -inf to +inf). 1 moves the
  # item one position forward, -1 moves the item one position backward, 0 leaves
  # the item unchanged.
  sortOrder: Int
}

enum ReportingPeriod {
  TODAY
  THIS_MONTH
}

enum ReportingPeriodV2 {
  TODAY
  THIS_WEEK
  THIS_MONTH
  THIS_QUARTER
  THIS_YEAR
}

# Request email change of the logged in user.
type RequestEmailChange {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Requests for OTP for registered user.
type RequestOTP {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Success messsage signifying an OTP has been sent to user's phone.
  message: String
  otpErrors: [OTPError!]!
}

# Sends an email with the account password modification link.
type RequestPasswordReset {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
}

# Sales allow creating discounts for categories, collections or products and are visible to all the customers.
type Sale implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  type: SaleType!
  value: Float!
  startDate: DateTime!
  endDate: DateTime
  # List of categories this sale applies to.
  categories(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CategoryCountableConnection
  # List of collections this sale applies to.
  collections(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CollectionCountableConnection
  # List of products this sale applies to.
  products(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductCountableConnection
  # Returns translated sale fields for the given language code.
  translation(
    # A language code to return the translation for sale.
    languageCode: LanguageCodeEnum!
  ): SaleTranslation
}

# Adds products, categories, collections to a voucher.
type SaleAddCatalogues {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Sale of which catalogue IDs will be modified.
  sale: Sale
  discountErrors: [DiscountError!]!
}

# Deletes sales.
type SaleBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  discountErrors: [DiscountError!]!
}

type SaleCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [SaleCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type SaleCountableEdge {
  # The item at the end of the edge.
  node: Sale!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new sale.
type SaleCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  discountErrors: [DiscountError!]!
  sale: Sale
}

# Deletes a sale.
type SaleDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  discountErrors: [DiscountError!]!
  sale: Sale
}

input SaleFilterInput {
  status: [DiscountStatusEnum]
  saleType: DiscountValueTypeEnum
  started: DateTimeRangeInput
  search: String
}

input SaleInput {
  # Voucher name.
  name: String
  # Fixed or percentage.
  type: DiscountValueTypeEnum
  # Value of the voucher.
  value: PositiveDecimal
  # Products related to the discount.
  products: [ID]
  # Categories related to the discount.
  categories: [ID]
  # Collections related to the discount.
  collections: [ID]
  # Start date of the voucher in ISO 8601 format.
  startDate: DateTime
  # End date of the voucher in ISO 8601 format.
  endDate: DateTime
}

# Removes products, categories, collections from a sale.
type SaleRemoveCatalogues {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Sale of which catalogue IDs will be modified.
  sale: Sale
  discountErrors: [DiscountError!]!
}

enum SaleSortField {
  # Sort sales by name.
  NAME
  # Sort sales by start date.
  START_DATE
  # Sort sales by end date.
  END_DATE
  # Sort sales by value.
  VALUE
  # Sort sales by type.
  TYPE
}

input SaleSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort sales by the selected field.
  field: SaleSortField!
}

type SaleTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Returns translated sale fields for the given language code.
  translation(
    # A language code to return the translation for sale.
    languageCode: LanguageCodeEnum!
  ): SaleTranslation
  # Sales allow creating discounts for categories, collections or products and are visible to all the customers.
  sale: Sale
}

# Creates/updates translations for a sale.
type SaleTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  sale: Sale
}

type SaleTranslation implements Node {
  # The ID of the object.
  id: ID!
  name: String
  # Translation language.
  language: LanguageDisplay!
}

# An enumeration.
enum SaleType {
  # INR
  FIXED
  # %
  PERCENTAGE
}

# Updates a sale.
type SaleUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  discountErrors: [DiscountError!]!
  sale: Sale
}

# Seachtap Search Input.
input SearchtapInput {
  # Fields List
  fields: [String]
  # Text Facets List
  textFacets: [String]
  # Highlight Fields List
  highlightFields: [String]
  # Search Fields List
  searchFields: [String]
  # Filter List
  filter: String
  # Sort List
  sort: String
  # Skip
  skip: Int
  # Count
  count: Int
  # Collection
  collection: String
  # Facet Count
  facetCount: Int
  # Group Count
  groupCount: Int
  # Typo Tolerance
  typoTolerance: Int
  # Text Facet Filters Color
  textFacetFiltersColor: [String]
  # Text Facet Filters Product Type
  textFacetFiltersProductType: [String]
  # Text Facet Filters Earphone Type
  textFacetFiltersEarphoneType: [String]
  # Numeric Facets
  numericFacets: JSONString
  # Numeric Facet Filters
  numericFacetFilters: [String]
  # Text Facet Query
  textFacetQuery: String
  # Geo
  geo: JSONString
}

# Adds products to a section.
type SectionAddProducts {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Add Products to Section.
  section: SectionType
  sectionErrors: [SectionError!]!
}

# Creates a new section.
type SectionCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  sectionErrors: [SectionError!]!
  section: SectionType
}

# Deletes a section.
type SectionDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  sectionErrors: [SectionError!]!
  section: SectionType
}

type SectionError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: SectionErrorCode!
}

# An enumeration.
enum SectionErrorCode {
  INVALID
  REQUIRED
  NOT_SECTIONS_IMAGE
}

input SectionFilterInput {
  isPublished: Boolean
  collections: [ID]
  categories: [ID]
  search: String
  ids: [ID]
}

# Create a product image. This mutation must be sent as a `multipart` request.
# More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type SectionImageCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Add Images to Section.
  section: SectionType
  image: SectionImageType
  sectionErrors: [SectionError!]!
}

input SectionImageCreateInput {
  # Alt text for an image.
  alt: String
  # Represents an image file in a multipart request.
  image: Upload!
  # ID of an section.
  section: ID!
}

# Deletes a section image.
type SectionImageDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Delete Images from Section.
  section: SectionType
  image: SectionImageType
  sectionErrors: [SectionError!]!
}

# Changes ordering of the section image.
type SectionImageReorder {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Delete Images from Section.
  section: SectionType
  images: [SectionImageType]
  sectionErrors: [SectionError!]!
}

type SectionImageType implements Node {
  sortOrder: Int
  # The ID of the object.
  id: ID!
  section: SectionType!
  images: String!
  ppoi: String!
  alt: String!
  # The URL of the image.
  url(
    # Size of the image.
    size: Int
  ): String!
}

type SectionImageTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [SectionImageTypeEdge]!
}

# A Relay edge containing a `SectionImageType` and its cursor.
type SectionImageTypeEdge {
  # The item at the end of the edge
  node: SectionImageType
  # A cursor for use in pagination
  cursor: String!
}

input SectionInput {
  # Informs whether a section is published.
  isPublished: Boolean
  # Name of the section.
  name: String
  # List of IDs of collections to be added to the section.
  collections: [ID]
  # List of IDs of categories to be added to the section.
  categories: [ID]
  # Description of the section (HTML/text).
  description: String
  # Description of the section (JSON).
  descriptionJson: JSONString
  # Background image file.
  backgroundImage: Upload
  # Alt text for an image.
  backgroundImageAlt: String
  # Publication date. ISO 8601 standard.
  publicationDate: Date
}

input SectionProductOrder {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort products by the selected field.
  field: SectionProductOrderField
}

enum SectionProductOrderField {
  # Sort products by name.
  NAME
  # Sort products by section. Note: This option is available only for the `Sections.products` query.
  SECTION
}

# Remove products from a section.
type SectionRemoveProducts {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Remove Products from Section.
  section: SectionType
  sectionErrors: [SectionError!]!
}

# Reorder the products of a section.
type SectionReorderProducts {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Section from which products are reordered.
  section: SectionType
  productErrors: [ProductError!]!
}

type SectionType implements Node & ObjectWithMetadataV2 {
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItemV2]!
  publicationDate: Date
  isPublished: Boolean!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItemV2]!
  # The ID of the object.
  id: ID!
  name: String!
  description: String!
  descriptionPlaintext: String!
  descriptionJson: JSONString!
  # List of products in this collection.
  products(
    # Sort products.
    sortBy: SectionProductOrder
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductCountableConnection
  collections(
    before: String
    after: String
    first: Int
    last: Int
  ): CollectionCountableConnection!
  categories(
    before: String
    after: String
    first: Int
    last: Int
  ): CategoryCountableConnection!
  backgroundImage(
    # Size of the image.
    size: Int
  ): Image
  backgroundImageAlt: String!
  updatedAt: DateTime
  parent: SectionType
  lft: Int!
  rght: Int!
  treeId: Int!
  level: Int!
  children(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    name: String
    isPublished: Boolean
  ): SectionTypeCountableConnection!
  images(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
  ): SectionImageTypeConnection!
}

type SectionTypeCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [SectionTypeCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type SectionTypeCountableEdge {
  # The item at the end of the edge.
  node: SectionType!
  # A cursor for use in pagination.
  cursor: String!
}

# Updates a section.
type SectionUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  sectionErrors: [SectionError!]!
  section: SectionType
}

# Represents a custom attribute.
type SelectedAttribute {
  # Name of an attribute displayed in the interface.
  attribute: Attribute!
  # Values of an attribute.
  values: [AttributeValue]!
}

input SeoInput {
  # SEO title.
  title: String
  # SEO description.
  description: String
}

# Represents service account data.
type ServiceAccount implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  # Name of the service account.
  name: String
  # The date and time when the service account was created.
  created: DateTime
  # Determine if service account will be set active or not.
  isActive: Boolean
  # List of the service's permissions.
  permissions: [Permission]
  # Last 4 characters of the tokens.
  tokens: [ServiceAccountToken]
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
}

# Clear private metadata for a service account.
type ServiceAccountClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  serviceAccount: ServiceAccount
}

type ServiceAccountCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ServiceAccountCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ServiceAccountCountableEdge {
  # The item at the end of the edge.
  node: ServiceAccount!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new service account.
type ServiceAccountCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The newly created authentication token.
  authToken: String
  accountErrors: [AccountError!]!
  serviceAccount: ServiceAccount
}

# Deletes a service account.
type ServiceAccountDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  serviceAccount: ServiceAccount
}

input ServiceAccountFilterInput {
  search: String
  isActive: Boolean
}

input ServiceAccountInput {
  # Name of the service account.
  name: String
  # Determine if this service account should be enabled.
  isActive: Boolean
  # List of permission code names to assign to this service account.
  permissions: [PermissionEnum]
}

enum ServiceAccountSortField {
  # Sort service accounts by name.
  NAME
  # Sort service accounts by creation date.
  CREATION_DATE
}

input ServiceAccountSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort service accounts by the selected field.
  field: ServiceAccountSortField!
}

# Represents token data.
type ServiceAccountToken implements Node {
  # Name of the authenticated token.
  name: String
  # Last 4 characters of the token.
  authToken: String
  # The ID of the object.
  id: ID!
}

# Creates a new token.
type ServiceAccountTokenCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The newly created authentication token.
  authToken: String
  accountErrors: [AccountError!]!
  serviceAccountToken: ServiceAccountToken
}

# Deletes an authentication token assigned to service account.
type ServiceAccountTokenDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  serviceAccountToken: ServiceAccountToken
}

input ServiceAccountTokenInput {
  # Name of the token.
  name: String
  # ID of service account.
  serviceAccount: ID!
}

# Updates an existing service account.
type ServiceAccountUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  serviceAccount: ServiceAccount
}

# Updates private metadata for a service account.
type ServiceAccountUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  serviceAccount: ServiceAccount
}

# Sets the user's password from the token sent by email using the RequestPasswordReset mutation.
type SetPassword {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # JWT token, required to authenticate.
  token: String
  # JWT refresh token, required to re-generate access token.
  refreshToken: String
  # CSRF token required to re-generate access token.
  csrfToken: String
  # A user instance.
  user: User
  accountErrors: [AccountError!]!
}

type ShipmentItemType implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  itemId: String!
  shipment: ShipmentType!
  productId: String!
  itemName: String!
  itemQuantity: Int!
  createdAt: DateTime!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
}

type ShipmentItemTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [ShipmentItemTypeEdge]!
}

# A Relay edge containing a `ShipmentItemType` and its cursor.
type ShipmentItemTypeEdge {
  # The item at the end of the edge
  node: ShipmentItemType
  # A cursor for use in pagination
  cursor: String!
}

type ShipmentType implements Node & ObjectWithMetadata {
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # The ID of the object.
  id: ID!
  storeId: String!
  shipmentId: String!
  fulfillmentId: String!
  awbNumber: String
  courierName: String
  estimateDeliveryDate: DateTime
  deliveredAt: DateTime
  status: String!
  order: Order
  trackingUrl: String
  invoiceUrl: String
  createdAt: DateTime!
  modifiedAt: DateTime!
  shipments(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
  ): ShipmentItemTypeConnection!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # A list of shipment items, each containing information about an item in the shipment.
  items: [ShipmentItemType]
  # Phone Number of the User
  phone: String
}

type ShipmentTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [ShipmentTypeEdge]!
}

# A Relay edge containing a `ShipmentType` and its cursor.
type ShipmentTypeEdge {
  # The item at the end of the edge
  node: ShipmentType
  # A cursor for use in pagination
  cursor: String!
}

type ShippingError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ShippingErrorCode!
  # List of warehouse IDs which causes the error.
  warehouses: [ID!]
}

# An enumeration.
enum ShippingErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  MAX_LESS_THAN_MIN
  NOT_FOUND
  REQUIRED
  UNIQUE
  DUPLICATED_INPUT_ITEM
}

# Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers.
type ShippingMethod implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  price: Money
  minimumOrderPrice: Money
  maximumOrderPrice: Money
  minimumOrderWeight: Weight
  maximumOrderWeight: Weight
  # Type of the shipping method.
  type: ShippingMethodTypeEnum
  # Returns translated shipping method fields for the given language code.
  translation(
    # A language code to return the translation for shipping method.
    languageCode: LanguageCodeEnum!
  ): ShippingMethodTranslation
}

type ShippingMethodTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Returns translated shipping method fields for the given language code.
  translation(
    # A language code to return the translation for shipping method.
    languageCode: LanguageCodeEnum!
  ): ShippingMethodTranslation
  # Shipping method are the methods you'll use to get customer's orders  to them. They are directly exposed to the customers.
  shippingMethod: ShippingMethod
}

type ShippingMethodTranslation implements Node {
  # The ID of the object.
  id: ID!
  name: String
  # Translation language.
  language: LanguageDisplay!
}

# An enumeration.
enum ShippingMethodTypeEnum {
  PRICE
  WEIGHT
}

# Deletes shipping prices.
type ShippingPriceBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  shippingErrors: [ShippingError!]!
}

# Creates a new shipping price.
type ShippingPriceCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A shipping zone to which the shipping method belongs.
  shippingZone: ShippingZone
  shippingErrors: [ShippingError!]!
  shippingMethod: ShippingMethod
}

# Deletes a shipping price.
type ShippingPriceDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A shipping method to delete.
  shippingMethod: ShippingMethod
  # A shipping zone to which the shipping method belongs.
  shippingZone: ShippingZone
  shippingErrors: [ShippingError!]!
}

input ShippingPriceInput {
  # Name of the shipping method.
  name: String
  # Shipping price of the shipping method.
  price: PositiveDecimal
  # Minimum order price to use this shipping method.
  minimumOrderPrice: PositiveDecimal
  # Maximum order price to use this shipping method.
  maximumOrderPrice: PositiveDecimal
  # Minimum order weight to use this shipping method.
  minimumOrderWeight: WeightScalar
  # Maximum order weight to use this shipping method.
  maximumOrderWeight: WeightScalar
  # Shipping type: price or weight based.
  type: ShippingMethodTypeEnum
  # Shipping zone this method belongs to.
  shippingZone: ID
}

# Creates/Updates translations for shipping method.
type ShippingPriceTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  shippingMethod: ShippingMethod
}

# Updates a new shipping price.
type ShippingPriceUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A shipping zone to which the shipping method belongs.
  shippingZone: ShippingZone
  shippingErrors: [ShippingError!]!
  shippingMethod: ShippingMethod
}

# Represents a shipping zone in the shop. Zones are the concept used only for
# grouping shipping methods in the dashboard, and are never exposed to the
# customers directly.
type ShippingZone implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  default: Boolean!
  # Lowest and highest prices for the shipping.
  priceRange: MoneyRange
  # List of countries available for the method.
  countries: [CountryDisplay]
  # List of shipping methods available for orders shipped to countries within this shipping zone.
  shippingMethods: [ShippingMethod]
  # List of warehouses for shipping zone.
  warehouses: [Warehouse]
}

# Deletes shipping zones.
type ShippingZoneBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  shippingErrors: [ShippingError!]!
}

type ShippingZoneCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ShippingZoneCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ShippingZoneCountableEdge {
  # The item at the end of the edge.
  node: ShippingZone!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new shipping zone.
type ShippingZoneCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  shippingErrors: [ShippingError!]!
  shippingZone: ShippingZone
}

input ShippingZoneCreateInput {
  # Shipping zone's name. Visible only to the staff.
  name: String
  # List of countries in this shipping zone.
  countries: [String]
  # Default shipping zone will be used for countries not covered by other zones.
  default: Boolean
  # List of warehouses to assign to a shipping zone
  addWarehouses: [ID]
}

# Deletes a shipping zone.
type ShippingZoneDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  shippingErrors: [ShippingError!]!
  shippingZone: ShippingZone
}

# Updates a new shipping zone.
type ShippingZoneUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  shippingErrors: [ShippingError!]!
  shippingZone: ShippingZone
}

input ShippingZoneUpdateInput {
  # Shipping zone's name. Visible only to the staff.
  name: String
  # List of countries in this shipping zone.
  countries: [String]
  # Default shipping zone will be used for countries not covered by other zones.
  default: Boolean
  # List of warehouses to assign to a shipping zone
  addWarehouses: [ID]
  # List of warehouses to unassign from a shipping zone
  removeWarehouses: [ID]
}

# Represents a shop resource containing general shop data and configuration.
type Shop {
  # List of available payment gateways.
  availablePaymentGateways(
    # A currency for which gateways will be returned.
    currency: String
  ): [PaymentGateway!]!
  # Customer's geolocalization data.
  geolocalization: Geolocalization
    @deprecated(
      reason: "Server-side geolocalization will be dropped in Saleor 3.0."
    )
  # List of configured authorization keys. Authorization keys are used to enable
  # third-party OAuth authorization (currently Facebook or Google).
  authorizationKeys: [AuthorizationKey]!
  # List of countries available in the shop.
  countries(
    # A language code to return the translation for.
    languageCode: LanguageCodeEnum
  ): [CountryDisplay!]!
  # List of available currencies.
  currencies: [String]!
    @deprecated(reason: "This field will be removed in Saleor 3.0")
  # Shop's default currency.
  defaultCurrency: String!
    @deprecated(reason: "This field will be removed in Saleor 3.0")
  # Shop's default country.
  defaultCountry: CountryDisplay
  # Default shop's email sender's name.
  defaultMailSenderName: String
  # Default shop's email sender's address.
  defaultMailSenderAddress: String
  # Shop's description.
  description: String
  # Shop's domain data.
  domain: Domain!
  # Collection displayed on homepage.
  homepageCollection: Collection
    @deprecated(
      reason: "Use the `collection` query with the `slug` parameter. This field will be removed in Saleor 3.0"
    )
  # List of the shops's supported languages.
  languages: [LanguageDisplay]!
  # Shop's name.
  name: String!
  # Shop's navigation.
  navigation: Navigation
    @deprecated(
      reason: "Fetch menus using the `menu` query with `slug` parameter."
    )
  # List of available permissions.
  permissions: [Permission]!
  # List of possible phone prefixes.
  phonePrefixes: [String]!
  # Header text.
  headerText: String
  # Include taxes in prices.
  includeTaxesInPrices: Boolean!
  # Display prices with tax in store.
  displayGrossPrices: Boolean!
  # Charge taxes on shipping.
  chargeTaxesOnShipping: Boolean!
  # Enable inventory tracking.
  trackInventoryByDefault: Boolean
  # Default weight unit.
  defaultWeightUnit: WeightUnitsEnum
  # Returns translated shop fields for the given language code.
  translation(
    # A language code to return the translation for shop.
    languageCode: LanguageCodeEnum!
  ): ShopTranslation
  # Enable automatic fulfillment for all digital products.
  automaticFulfillmentDigitalProducts: Boolean
  # Default number of max downloads per digital content URL.
  defaultDigitalMaxDownloads: Int
  # Default number of days which digital content URL will be valid.
  defaultDigitalUrlValidDays: Int
  # Company address.
  companyAddress: Address
  # URL of a view where customers can set their password.
  customerSetPasswordUrl: String
  # List of staff notification recipients.
  staffNotificationRecipients: [StaffNotificationRecipient]
}

# Update the shop's address. If the `null` value is passed, the currently selected address will be deleted.
type ShopAddressUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated shop.
  shop: Shop
  shopErrors: [ShopError!]!
}

# Updates site domain of the shop.
type ShopDomainUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated shop.
  shop: Shop
  shopErrors: [ShopError!]!
}

type ShopError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ShopErrorCode!
}

# An enumeration.
enum ShopErrorCode {
  ALREADY_EXISTS
  CANNOT_FETCH_TAX_RATES
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

# Fetch tax rates.
type ShopFetchTaxRates {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated shop.
  shop: Shop
  shopErrors: [ShopError!]!
}

type ShopifyGiftCardType implements Node {
  giftCardId: String!
  giftCard: String
  # The ID of the object.
  id: ID!
}

type ShopifyOrderType implements Node {
  # shopify order id
  id: ID!
  # Shopify Order payload
  shopifyOrder: JSONString
  # Order
  order: Order
  # Billing Address of the Order
  billingAddress: Address
  # Shipping Address of the Order
  shippingAddress: Address
  # List of order lines.
  lines: [OrderLine]
}

type ShopifyUserError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ShopifyUserErrorCode!
}

# An enumeration.
enum ShopifyUserErrorCode {
  REQUIRED
}

# Shopify Ids mapping Details.
input ShopifyUserInput {
  # Shopify User Id
  shopifyUserId: String!
  # User Id
  userId: ID
  # Gift card
  giftCard: String!
}

type ShopifyUserType implements Node {
  shopifyUserId: String!
  user: User
  giftCard: String
  # The ID of the object.
  id: ID!
}

type ShopMetaType implements Node & ObjectWithMetadataV2 {
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItemV2]!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItemV2]!
  # The ID of the object.
  id: ID!
  name: String!
}

type ShopMetaTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [ShopMetaTypeEdge]!
}

# A Relay edge containing a `ShopMetaType` and its cursor.
type ShopMetaTypeEdge {
  # The item at the end of the edge
  node: ShopMetaType
  # A cursor for use in pagination
  cursor: String!
}

input ShopSettingsInput {
  # Header text.
  headerText: String
  # SEO description.
  description: String
  # Include taxes in prices.
  includeTaxesInPrices: Boolean
  # Display prices with tax in store.
  displayGrossPrices: Boolean
  # Charge taxes on shipping.
  chargeTaxesOnShipping: Boolean
  # Enable inventory tracking.
  trackInventoryByDefault: Boolean
  # Default weight unit.
  defaultWeightUnit: WeightUnitsEnum
  # Enable automatic fulfillment for all digital products.
  automaticFulfillmentDigitalProducts: Boolean
  # Default number of max downloads per digital content URL.
  defaultDigitalMaxDownloads: Int
  # Default number of days which digital content URL will be valid.
  defaultDigitalUrlValidDays: Int
  # Default email sender's name.
  defaultMailSenderName: String
  # Default email sender's address.
  defaultMailSenderAddress: String
  # URL of a view where customers can set their password.
  customerSetPasswordUrl: String
}

# Creates/Updates translations for Shop Settings.
type ShopSettingsTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated shop.
  shop: Shop
  translationErrors: [TranslationError!]!
}

input ShopSettingsTranslationInput {
  headerText: String
  description: String
}

# Updates shop settings.
type ShopSettingsUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Updated shop.
  shop: Shop
  shopErrors: [ShopError!]!
}

type ShopTranslation implements Node {
  # The ID of the object.
  id: ID!
  headerText: String!
  description: String!
  # Translation language.
  language: LanguageDisplay!
}

input SiteDomainInput {
  # Domain name for shop.
  domain: String
  # Shop site name.
  name: String
}

# Deletes staff users.
type StaffBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  staffErrors: [StaffError!]!
}

# Creates a new staff user.
type StaffCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  staffErrors: [StaffError!]!
  user: User
}

input StaffCreateInput {
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # The unique email address of the user.
  email: String
  # User account is active.
  isActive: Boolean
  # A note about the user.
  note: String
  # List of permission group IDs to which user should be assigned.
  addGroups: [ID!]
  # URL of a view where users should be redirected to set the password. URL in RFC 1808 format.
  redirectUrl: String
}

# Deletes a staff user.
type StaffDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  staffErrors: [StaffError!]!
  user: User
}

type StaffError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: AccountErrorCode!
  # List of permissions which causes the error.
  permissions: [PermissionEnum!]
  # List of permission group IDs which cause the error.
  groups: [ID!]
  # List of user IDs which causes the error.
  users: [ID!]
}

enum StaffMemberStatus {
  ACTIVE
  DEACTIVATED
}

# Represents a recipient of email notifications send by Saleor, such as
# notifications about new orders. Notifications can be assigned to staff users or
# arbitrary email addresses.
type StaffNotificationRecipient implements Node {
  # Returns a user subscribed to email notifications.
  user: User
  # Determines if a notification active.
  active: Boolean
  # The ID of the object.
  id: ID!
  # Returns email address of a user subscribed to email notifications.
  email: String
}

# Creates a new staff notification recipient.
type StaffNotificationRecipientCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  shopErrors: [ShopError!]!
  staffNotificationRecipient: StaffNotificationRecipient
}

# Delete staff notification recipient.
type StaffNotificationRecipientDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  shopErrors: [ShopError!]!
  staffNotificationRecipient: StaffNotificationRecipient
}

input StaffNotificationRecipientInput {
  # The ID of the user subscribed to email notifications..
  user: ID
  # Email address of a user subscribed to email notifications.
  email: String
  # Determines if a notification active.
  active: Boolean
}

# Updates a staff notification recipient.
type StaffNotificationRecipientUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  shopErrors: [ShopError!]!
  staffNotificationRecipient: StaffNotificationRecipient
}

# Updates an existing staff user.
type StaffUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  staffErrors: [StaffError!]!
  user: User
}

input StaffUpdateInput {
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # The unique email address of the user.
  email: String
  # User account is active.
  isActive: Boolean
  # A note about the user.
  note: String
  # List of permission group IDs to which user should be assigned.
  addGroups: [ID!]
  # List of permission group IDs from which user should be unassigned.
  removeGroups: [ID!]
}

input StaffUserInput {
  status: StaffMemberStatus
  search: String
}

enum StatusType {
  ACTIVE
  EXPIRED
  SCHEDULED
}

# An enumeration.
enum StatusTypes {
  ACTIVE
  CANCELLED
  PAUSED
}

# Represents stock.
type Stock implements Node {
  warehouse: Warehouse!
  productVariant: ProductVariant!
  # Quantity of a product in the warehouse's possession, including the allocated stock that is waiting for shipment.
  quantity: Int!
  # The ID of the object.
  id: ID!
  # Quantity allocated for orders
  quantityAllocated: Int!
}

enum StockAvailability {
  IN_STOCK
  OUT_OF_STOCK
}

type StockCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [StockCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type StockCountableEdge {
  # The item at the end of the edge.
  node: Stock!
  # A cursor for use in pagination.
  cursor: String!
}

type StockError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: StockErrorCode!
}

# An enumeration.
enum StockErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

input StockFilterInput {
  quantity: Float
  search: String
}

input StockInput {
  # Warehouse in which stock is located.
  warehouse: ID!
  # Quantity of items available for sell.
  quantity: Int
}

# Create Subscription.
type SubscriptionCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Subscription instance.
  subscription: SubscriptionType
  subscriptionErrors: [SubscriptionError!]!
}

type SubscriptionError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: SubscriptionErrorCode!
}

# An enumeration.
enum SubscriptionErrorCode {
  INVALID
  REQUIRED
}

input SubscriptionInput {
  # Product Id
  productId: ID!
  # User Id
  userId: String!
  # Quantity for the product
  quantity: [ID]!
  # Status of the Subscription
  status: StatusTypes!
}

# An enumeration.
enum SubscriptionStatus {
  # ACT
  STATUSTYPES_ACTIVE
  # CNC
  STATUSTYPES_CANCELLED
  # PAU
  STATUSTYPES_PAUSED
}

type SubscriptionType implements Node {
  metadata: JSONString
  # The ID of the object.
  id: ID!
  privateMetadata: JSONString
  user: User
  product: Product!
  quantity: [Int!]!
  quantityIndex: Int!
  quantityLength: Int!
  payment: String!
  status: SubscriptionStatus!
  startDate: DateTime!
  endDate: DateTime
  created: DateTime!
  updated: DateTime!
}

type SubscriptionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [SubscriptionTypeEdge]!
}

# A Relay edge containing a `SubscriptionType` and its cursor.
type SubscriptionTypeEdge {
  # The item at the end of the edge
  node: SubscriptionType
  # A cursor for use in pagination
  cursor: String!
}

input SurveyAnswerInput {
  # SurveyQuestion instance ID.
  question: ID!
  # Survey answer of type String, can accept string as well as integers.
  answer: String!
}

type SurveyAnswerType implements Node {
  # The ID of the object.
  id: ID!
  question: SurveyQuestionType!
  answer: String!
  created: DateTime!
}

type SurveyAnswerTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [SurveyAnswerTypeEdge]!
}

# A Relay edge containing a `SurveyAnswerType` and its cursor.
type SurveyAnswerTypeEdge {
  # The item at the end of the edge
  node: SurveyAnswerType
  # A cursor for use in pagination
  cursor: String!
}

# Create Survey.
type SurveyCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # List of Survey instances.
  surveys: [SurveyType]
  SurveyErrors: [SurveyError!]!
}

# Delete Survey.
type SurveyDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Survey instance.
  survey: SurveyType
  surveyErrors: [SurveyError!]!
}

type SurveyError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: SurveyErrorCode!
}

# An enumeration.
enum SurveyErrorCode {
  NAME_REQUIRED
  QUESTIONS_REQUIRED
  SURVEY_ALREADY_EXISTS
  INVALID
  REQUIRED
}

# Fill Survey.
type SurveyFill {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Survey instance.
  survey: SurveyType
  surveyErrors: [SurveyError!]!
}

type SurveyFillType implements Node {
  name: String!
  shown: Boolean!
  attempted: Boolean!
  questions(
    before: String
    after: String
    first: Int
    last: Int
  ): SurveyQuestionTypeConnection!
  # The ID of the object.
  id: ID!
}

input SurveyInput {
  # Name given by user.
  name: String!
}

type SurveyLinkData {
  surveyHash: String
  surveyId: String
  orderId: String
  userId: String
}

input SurveyQuestionInput {
  # Survey Question text.
  text: String!
  # Order at which this question will be shown.
  order: Int
  # Whether this question is required or not
  required: Boolean
}

type SurveyQuestionType implements Node {
  # The ID of the object.
  id: ID!
  text: String!
  order: Int!
  required: Boolean!
  survey: SurveyType!
  answers(
    before: String
    after: String
    first: Int
    last: Int
  ): SurveyAnswerTypeConnection!
}

type SurveyQuestionTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [SurveyQuestionTypeEdge]!
}

# A Relay edge containing a `SurveyQuestionType` and its cursor.
type SurveyQuestionTypeEdge {
  # The item at the end of the edge
  node: SurveyQuestionType
  # A cursor for use in pagination
  cursor: String!
}

type SurveyType implements Node {
  name: String!
  shown: Boolean!
  attempted: Boolean!
  questions(
    before: String
    after: String
    first: Int
    last: Int
  ): SurveyQuestionTypeConnection!
  # The ID of the object.
  id: ID!
  user: User
  order: Order
  surveyHash: String
  created: DateTime!
  linkData: SurveyLinkData
}

type SurveyTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [SurveyTypeEdge]!
}

# A Relay edge containing a `SurveyType` and its cursor.
type SurveyTypeEdge {
  # The item at the end of the edge
  node: SurveyType
  # A cursor for use in pagination
  cursor: String!
}

# Sync Inventory with WareIq.
type SyncWareIqInventory {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
}

# Represents a monetary value with taxes. In cases where taxes were not applied, net and gross values will be equal.
type TaxedMoney {
  # Currency code.
  currency: String!
  # Amount of money including taxes.
  gross: Money!
  # Amount of money without taxes.
  net: Money!
  # Amount of taxes.
  tax: Money!
}

# Represents a range of monetary values.
type TaxedMoneyRange {
  # Lower bound of a price range.
  start: TaxedMoney
  # Upper bound of a price range.
  stop: TaxedMoney
}

# An enumeration.
enum TaxRateType {
  ACCOMMODATION
  ADMISSION_TO_CULTURAL_EVENTS
  ADMISSION_TO_ENTERTAINMENT_EVENTS
  ADMISSION_TO_SPORTING_EVENTS
  ADVERTISING
  AGRICULTURAL_SUPPLIES
  BABY_FOODSTUFFS
  BIKES
  BOOKS
  CHILDRENS_CLOTHING
  DOMESTIC_FUEL
  DOMESTIC_SERVICES
  E_BOOKS
  FOODSTUFFS
  HOTELS
  MEDICAL
  NEWSPAPERS
  PASSENGER_TRANSPORT
  PHARMACEUTICALS
  PROPERTY_RENOVATIONS
  RESTAURANTS
  SOCIAL_HOUSING
  STANDARD
  WATER
  WINE
}

# Representation of tax types fetched from tax gateway.
type TaxType {
  # Description of the tax type.
  description: String
  # External tax code used to identify given tax group.
  taxCode: String
}

# Requests for Token for registered user.
type TokenCreateWithAdmin {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Access token for a user.
  accessToken: String
  # CSRF token required to re-generate access token.
  csrfToken: String
}

# An object representing a single payment.
type Transaction implements Node {
  # The ID of the object.
  id: ID!
  created: DateTime!
  payment: Payment!
  token: String!
  kind: TransactionKind!
  isSuccess: Boolean!
  error: TransactionError
  # Total amount of the transaction.
  amount: Money
}

# An enumeration.
enum TransactionError {
  # incorrect_number
  TRANSACTIONERROR_INCORRECT_NUMBER
  # invalid_number
  TRANSACTIONERROR_INVALID_NUMBER
  # incorrect_cvv
  TRANSACTIONERROR_INCORRECT_CVV
  # invalid_cvv
  TRANSACTIONERROR_INVALID_CVV
  # incorrect_zip
  TRANSACTIONERROR_INCORRECT_ZIP
  # incorrect_address
  TRANSACTIONERROR_INCORRECT_ADDRESS
  # invalid_expiry_date
  TRANSACTIONERROR_INVALID_EXPIRY_DATE
  # expired
  TRANSACTIONERROR_EXPIRED
  # processing_error
  TRANSACTIONERROR_PROCESSING_ERROR
  # declined
  TRANSACTIONERROR_DECLINED
}

# An enumeration.
enum TransactionKind {
  # Authorization
  AUTH
  # Pending
  PENDING
  # Action to confirm
  ACTION_TO_CONFIRM
  # Refund
  REFUND
  # Refund in progress
  REFUND_ONGOING
  # Capture
  CAPTURE
  # Void
  VOID
  # Confirm
  CONFIRM
  # Cancel
  CANCEL
}

union TranslatableItem =
    ProductTranslatableContent
  | CollectionTranslatableContent
  | CategoryTranslatableContent
  | AttributeTranslatableContent
  | AttributeValueTranslatableContent
  | ProductVariantTranslatableContent
  | PageTranslatableContent
  | ShippingMethodTranslatableContent
  | SaleTranslatableContent
  | VoucherTranslatableContent
  | MenuItemTranslatableContent
type TranslatableItemConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [TranslatableItemEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type TranslatableItemEdge {
  # The item at the end of the edge.
  node: TranslatableItem!
  # A cursor for use in pagination.
  cursor: String!
}

enum TranslatableKinds {
  ATTRIBUTE
  ATTRIBUTE_VALUE
  CATEGORY
  COLLECTION
  MENU_ITEM
  PAGE
  PRODUCT
  SALE
  SHIPPING_METHOD
  VARIANT
  VOUCHER
}

type TranslationError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: TranslationErrorCode!
}

# An enumeration.
enum TranslationErrorCode {
  GRAPHQL_ERROR
  NOT_FOUND
  REQUIRED
}

input TranslationInput {
  seoTitle: String
  seoDescription: String
  name: String
  description: String
  descriptionJson: JSONString
}

# Update an address type
type UpdateAddressType {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An address link instance between address and its type.
  addressLink: AddressLinkType
}

# Update a banner
type UpdateBanner {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A banner instance.
  banner: CustomBannerType
  bannerErrors: [BannerError!]!
}

# Update an Influencer.
type UpdateInfluencer {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An Influencer instance.
  influencer: InfluencerType
}

input UpdateInvoiceInput {
  # Invoice number
  number: String
  # URL of an invoice to download.
  url: String
}

# Updates metadata of an object.
type UpdateMetadata {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadata
}

# Updates metadata of an object.
type UpdateMetadataV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadataV2
}

# Set the payment method of checkout
type UpdatePaymentMethod {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A checkout instance.
  checkout: Checkout
  checkoutErrors: [CheckoutError!]!
}

# Updates private metadata of an object.
type UpdatePrivateMetadata {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadata
}

# Updates private metadata of an object.
type UpdatePrivateMetadataV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadataV2
}

# Update Product Pricing on Shopify.
type UpdateShopifyProductPriceCSV {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Product instance.
  productVariant: ProductVariant
  productErrors: [ProductError!]!
}

# Update Product Tags on Shopify.
type UpdateShopifyProductTagsCSV {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Product instance.
  product: Product
  productErrors: [ProductError!]!
}

# Update an ShopifyUser.
type UpdateShopifyUser {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An ShopifyUser instance.
  shopifyUser: ShopifyUserType
}

# Update a subscription.
type UpdateSubscription {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A subscription instance
  subscription: SubscriptionType
  subscriptionError: [SubscriptionError!]!
}

# Update a voucher rule.
type UpdateVoucherRule {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A voucher rule instance.
  voucherRule: VoucherRuleType
  voucherErrors: [VoucherError!]!
}

# Update a voucher rule link.
type UpdateVoucherRuleLink {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A voucher rule link instance.
  voucherRuleLink: VoucherRuleLinkType
  voucherErrors: [VoucherError!]!
}

# Variables of this type must be set to null in mutations. They will be replaced
# with a filename from a following multipart part containing a binary file. See:
# https://github.com/jaydenseric/graphql-multipart-request-spec.
scalar Upload

# Represents user data.
type User implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  lastLogin: DateTime
  email: String!
  firstName: String!
  lastName: String!
  isStaff: Boolean!
  isActive: Boolean!
  # A note about the customer.
  note: String
  dateJoined: DateTime!
  defaultShippingAddress: Address
  defaultBillingAddress: Address
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of privately stored metadata namespaces.
  privateMeta: [MetaStore]!
    @deprecated(
      reason: "Use the `privetaMetadata` field. This field will be removed after 2020-07-31."
    )
  # List of publicly stored metadata namespaces.
  meta: [MetaStore]!
    @deprecated(
      reason: "Use the `metadata` field. This field will be removed after 2020-07-31."
    )
  # The phone number of the user.
  phone: String
  # List of all user's addresses.
  addresses: [Address]
  # Returns the last open checkout of this user.
  checkout: Checkout
  # List of the user gift cards.
  giftCards(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): GiftCardCountableConnection
  # List of user's orders.
  orders(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): OrderCountableConnection
  # List of user's permissions.
  permissions: [Permission]
    @deprecated(
      reason: "Will be removed in Saleor 2.11.Use the `userPermissions` instead."
    )
  # List of user's permissions.
  userPermissions: [UserPermission]
  # List of user's permission groups.
  permissionGroups: [Group]
  # List of user's permission groups which user can manage.
  editableGroups: [Group]
  avatar(
    # Size of the avatar.
    size: Int
  ): Image
  # List of events associated with the user.
  events: [CustomerEvent]
  # List of stored payment sources.
  storedPaymentSources: [PaymentSource]
}

# Deletes a user avatar. Only for staff members.
type UserAvatarDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Deletes a user avatar. Only for staff members.
type UserAvatarDeleteV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Create a user avatar. Only for staff members. This mutation must be sent as a
# `multipart` request. More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type UserAvatarUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Create a user avatar. For all users. This mutation must be sent as a `multipart`
# request. More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type UserAvatarUpdateV2 {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Activate or deactivate users.
type UserBulkSetActive {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  accountErrors: [AccountError!]!
}

# Clear metadata for user.
type UserClearMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Clear private metadata for user.
type UserClearPrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

type UserCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [UserCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type UserCountableEdge {
  # The item at the end of the edge.
  node: User!
  # A cursor for use in pagination.
  cursor: String!
}

input UserCreateInput {
  # Billing address of the customer.
  defaultBillingAddress: AddressInput
  # Shipping address of the customer.
  defaultShippingAddress: AddressInput
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # The unique email address of the user.
  email: String
  # User account is active.
  isActive: Boolean
  # A note about the user.
  note: String
  # URL of a view where users should be redirected to set the password. URL in RFC 1808 format.
  redirectUrl: String
}

type UserPermission {
  # Internal code for permission.
  code: PermissionEnum!
  # Describe action(s) allowed to do by permission.
  name: String!
  # List of user permission groups which contains this permission.
  sourcePermissionGroups(
    # ID of user whose groups should be returned.
    userId: ID!
  ): [Group!]
}

enum UserSortField {
  # Sort users by first name.
  FIRST_NAME
  # Sort users by last name.
  LAST_NAME
  # Sort users by email.
  EMAIL
  # Sort users by order count.
  ORDER_COUNT
}

input UserSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort users by the selected field.
  field: UserSortField!
}

# Updates metadata for user.
type UserUpdateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Updates private metadata for user.
type UserUpdatePrivateMeta {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  accountErrors: [AccountError!]!
  user: User
}

scalar UUID

# Assign an image to a product variant.
type VariantImageAssign {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productVariant: ProductVariant
  image: ProductImage
  productErrors: [ProductError!]!
}

# Unassign an image from a product variant.
type VariantImageUnassign {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  productVariant: ProductVariant
  image: ProductImage
  productErrors: [ProductError!]!
}

input VariantInput {
  # variant id
  variantId: ID!
  # variant quantity
  quantity: Int!
}

# Represents availability of a variant in the storefront.
type VariantPricingInfo {
  # Whether it is in sale or not.
  onSale: Boolean
  # The discount amount if in sale (null otherwise).
  discount: TaxedMoney
  # The discount amount in the local currency.
  discountLocalCurrency: TaxedMoney
  # The price, with any discount subtracted.
  price: TaxedMoney
  # The price without any discount.
  priceUndiscounted: TaxedMoney
  # The discounted price in the local currency.
  priceLocalCurrency: TaxedMoney
}

# Represents a VAT rate for a country.
type VAT {
  # Country code.
  countryCode: String!
  # Standard VAT rate in percent.
  standardRate: Float
  # Country's VAT rate exceptions for specific types of goods.
  reducedRates: [ReducedRate]!
}

# Requests for OTP for registered user.
type VerifyCheckoutOTP {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Checks whether phone is verified or not
  isVerified: Boolean
  otpErrors: [OTPError!]!
}

# Verify JWT token.
type VerifyToken {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # User assigned to token.
  user: User
  # Determine if token is valid or not.
  isValid: Boolean!
  # JWT payload.
  payload: GenericScalar
  accountErrors: [AccountError!]!
}

# Vouchers allow giving discounts to particular customers on categories,
# collections or specific products. They can be used during checkout by providing
# valid voucher codes.
type Voucher implements Node {
  # The ID of the object.
  id: ID!
  name: String
  # Determines a type of voucher.
  type: VoucherTypeEnum!
  code: String!
  usageLimit: Int
  used: Int!
  startDate: DateTime!
  endDate: DateTime
  applyOncePerOrder: Boolean!
  applyOncePerCustomer: Boolean!
  # Determines a type of discount for voucher - value or percentage
  discountValueType: DiscountValueTypeEnum!
  discountValue: Float!
  minSpent: Money
  minCheckoutItemsQuantity: Int
  # List of categories this voucher applies to.
  categories(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CategoryCountableConnection
  # List of collections this voucher applies to.
  collections(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CollectionCountableConnection
  # List of products this voucher applies to.
  products(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductCountableConnection
  # List of countries available for the shipping voucher.
  countries: [CountryDisplay]
  # Returns translated voucher fields for the given language code.
  translation(
    # A language code to return the translation for voucher.
    languageCode: LanguageCodeEnum!
  ): VoucherTranslation
}

# Adds products, categories, collections to a voucher.
type VoucherAddCatalogues {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Voucher of which catalogue IDs will be modified.
  voucher: Voucher
  discountErrors: [DiscountError!]!
}

# Deletes vouchers.
type VoucherBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Returns how many objects were affected.
  count: Int!
  discountErrors: [DiscountError!]!
}

type VoucherCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [VoucherCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type VoucherCountableEdge {
  # The item at the end of the edge.
  node: Voucher!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new voucher.
type VoucherCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  discountErrors: [DiscountError!]!
  voucher: Voucher
}

# Deletes a voucher.
type VoucherDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  discountErrors: [DiscountError!]!
  voucher: Voucher
}

enum VoucherDiscountType {
  FIXED
  PERCENTAGE
  SHIPPING
}

type VoucherError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: VoucherRuleErrorCodeEnum
}

input VoucherFilterInput {
  status: [DiscountStatusEnum]
  timesUsed: IntRangeInput
  discountType: [VoucherDiscountType]
  started: DateTimeRangeInput
  search: String
}

input VoucherInput {
  # Voucher type: PRODUCT, CATEGORY SHIPPING or ENTIRE_ORDER.
  type: VoucherTypeEnum
  # Voucher name.
  name: String
  # Code to use the voucher.
  code: String
  # Start date of the voucher in ISO 8601 format.
  startDate: DateTime
  # End date of the voucher in ISO 8601 format.
  endDate: DateTime
  # Choices: fixed or percentage.
  discountValueType: DiscountValueTypeEnum
  # Value of the voucher.
  discountValue: PositiveDecimal
  # Products discounted by the voucher.
  products: [ID]
  # Collections discounted by the voucher.
  collections: [ID]
  # Categories discounted by the voucher.
  categories: [ID]
  # Min purchase amount required to apply the voucher.
  minAmountSpent: PositiveDecimal
  # Minimal quantity of checkout items required to apply the voucher.
  minCheckoutItemsQuantity: Int
  # Country codes that can be used with the shipping voucher.
  countries: [String]
  # Voucher should be applied to the cheapest item or entire order.
  applyOncePerOrder: Boolean
  # Voucher should be applied once per customer.
  applyOncePerCustomer: Boolean
  # Limit number of times this voucher can be used in total.
  usageLimit: Int
}

# Removes products, categories, collections from a voucher.
type VoucherRemoveCatalogues {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # Voucher of which catalogue IDs will be modified.
  voucher: Voucher
  discountErrors: [DiscountError!]!
}

# An enumeration.
enum VoucherRuleErrorCodeEnum {
  NOT_FOUND
  NOT_APPLICABLE
  NO_VOUCHER_LINKED_TO_CHECKOUT
  NO_VOUCHER_RULE_LINK_FOUND
  DUPLICATE_REQUEST
  VOUCHER_RULE_DISABLED
  INVALID
}

input VoucherRuleFilterInput {
  isDefault: Boolean
  isEnabled: Boolean
  name: String
  name_Icontains: String
  name_Istartswith: String
  id: ID
  links_Code: String
  startDate: DateTime
  startDate_Lte: DateTime
  startDate_Gte: DateTime
  endDate: DateTime
  endDate_Lte: DateTime
  endDate_Gte: DateTime
  searchVector: String
  # Status of voucher rule
  status: StatusType
}

input VoucherRuleInput {
  # Slug
  slug: String!
  # Rule name
  name: String!
  # Description of the rule
  description: String
  # Conditions for the rule to be applicable
  condition: JSONString!
  # Actions to perform if rule is applied
  action: JSONString!
  usePerCustomer: Int
  maxUsage: Int
  isEnabled: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
}

input VoucherRuleLinkInput {
  # Promo code
  code: String!
  # Rule Id
  rule: ID!
  isEnabled: Boolean
}

type VoucherRuleLinkType implements Node {
  # The ID of the object.
  id: ID!
  code: String!
  rule: VoucherRuleType!
  isEnabled: Boolean!
  created: DateTime!
}

type VoucherRuleLinkTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [VoucherRuleLinkTypeEdge]!
}

# A Relay edge containing a `VoucherRuleLinkType` and its cursor.
type VoucherRuleLinkTypeEdge {
  # The item at the end of the edge
  node: VoucherRuleLinkType
  # A cursor for use in pagination
  cursor: String!
}

input VoucherRuleOrder {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort Voucher Rules by the selected field.
  field: VoucherRuleOrderField
}

enum VoucherRuleOrderField {
  NAME
  START_DATE
  END_DATE
  MAX_USAGE
  CODE
}

type VoucherRuleType implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  slug: String!
  description: String
  condition: JSONString!
  action: JSONString!
  usePerCustomer: Int
  maxUsage: Int
  isEnabled: Boolean!
  isDefault: Boolean!
  created: DateTime!
  updated: DateTime!
  startDate: DateTime!
  endDate: DateTime
  links(
    before: String
    after: String
    first: Int
    last: Int
    code: String
    isEnabled: Boolean
    rule: ID
    id: ID
  ): VoucherRuleLinkTypeConnection!
  logs(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
  ): CouponDiscountTypeConnection!
}

type VoucherRuleTypeConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  # Contains the nodes in this connection.
  edges: [VoucherRuleTypeEdge]!
}

# A Relay edge containing a `VoucherRuleType` and its cursor.
type VoucherRuleTypeEdge {
  # The item at the end of the edge
  node: VoucherRuleType
  # A cursor for use in pagination
  cursor: String!
}

enum VoucherSortField {
  # Sort vouchers by code.
  CODE
  # Sort vouchers by start date.
  START_DATE
  # Sort vouchers by end date.
  END_DATE
  # Sort vouchers by value.
  VALUE
  # Sort vouchers by type.
  TYPE
  # Sort vouchers by usage limit.
  USAGE_LIMIT
  # Sort vouchers by minimum spent amount.
  MINIMUM_SPENT_AMOUNT
}

input VoucherSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort vouchers by the selected field.
  field: VoucherSortField!
}

type VoucherTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  name: String
  # Returns translated voucher fields for the given language code.
  translation(
    # A language code to return the translation for voucher.
    languageCode: LanguageCodeEnum!
  ): VoucherTranslation
  # Vouchers allow giving discounts to particular customers on categories,
  # collections or specific products. They can be used during checkout by
  # providing valid voucher codes.
  voucher: Voucher
}

# Creates/Updates translations for Voucher.
type VoucherTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  translationErrors: [TranslationError!]!
  voucher: Voucher
}

type VoucherTranslation implements Node {
  # The ID of the object.
  id: ID!
  name: String
  # Translation language.
  language: LanguageDisplay!
}

enum VoucherTypeEnum {
  SHIPPING
  ENTIRE_ORDER
  SPECIFIC_PRODUCT
}

# Updates a voucher.
type VoucherUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  discountErrors: [DiscountError!]!
  voucher: Voucher
}

# Add/Sub Wallet Balance of a user
type WalletBalanceUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # A Wallet instance.
  wallet: WalletType
  WalletErrors: [WalletError!]!
}

type WalletError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: WalletErrorCode!
}

# An enumeration.
enum WalletErrorCode {
  UNAUTHORIZED
}

input WalletInput {
  # User Id
  userId: ID!
  # Amount of wallet to update
  amount: Float!
  # Reason for updation
  reason: String!
  # ADD/SUB Option to update
  type: String!
  # Secret for updation
  secret: String!
}

# An enumeration.
enum WalletLogType {
  # Add
  ADD
  # Subtract
  SUB
}

type WalletType implements Node {
  # The ID of the object.
  id: ID!
  user: User!
  amount: Float!
  expiryDate: DateTime
  created: DateTime!
  updated: DateTime!
  logs(
    before: String
    after: String
    first: Int
    last: Int
    created: DateTime
  ): CustomWalletLogTypeConnection!
}

# Represents warehouse.
type Warehouse implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  slug: String!
  companyName: String!
  shippingZones(
    before: String
    after: String
    first: Int
    last: Int
  ): ShippingZoneCountableConnection!
  address: Address!
  email: String!
}

input WarehouseAddressInput {
  # Address.
  streetAddress1: String!
  # Address.
  streetAddress2: String
  # City.
  city: String!
  # District.
  cityArea: String
  # Postal code.
  postalCode: String
  # Country.
  country: CountryCode!
  # State or province.
  countryArea: String
  # Phone number.
  phone: String
}

type WarehouseCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [WarehouseCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type WarehouseCountableEdge {
  # The item at the end of the edge.
  node: Warehouse!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates new warehouse.
type WarehouseCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  warehouseErrors: [WarehouseError!]!
  warehouse: Warehouse
}

input WarehouseCreateInput {
  # Warehouse slug.
  slug: String
  # Company name.
  companyName: String
  # The email address of the warehouse.
  email: String
  # Warehouse name.
  name: String!
  # Address of the warehouse.
  address: WarehouseAddressInput!
  # Shipping zones supported by the warehouse.
  shippingZones: [ID]
}

# Deletes selected warehouse.
type WarehouseDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  warehouseErrors: [WarehouseError!]!
  warehouse: Warehouse
}

type WarehouseError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: WarehouseErrorCode!
}

# An enumeration.
enum WarehouseErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

input WarehouseFilterInput {
  search: String
  ids: [ID]
}

# Add shipping zone to given warehouse.
type WarehouseShippingZoneAssign {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  warehouseErrors: [WarehouseError!]!
  warehouse: Warehouse
}

# Remove shipping zone from given warehouse.
type WarehouseShippingZoneUnassign {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  warehouseErrors: [WarehouseError!]!
  warehouse: Warehouse
}

enum WarehouseSortField {
  # Sort warehouses by name.
  NAME
}

input WarehouseSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort warehouses by the selected field.
  field: WarehouseSortField!
}

# Updates given warehouse.
type WarehouseUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  warehouseErrors: [WarehouseError!]!
  warehouse: Warehouse
}

input WarehouseUpdateInput {
  # Warehouse slug.
  slug: String
  # Company name.
  companyName: String
  # The email address of the warehouse.
  email: String
  # Warehouse name.
  name: String
  # Address of the warehouse.
  address: WarehouseAddressInput
}

# Webhook.
type Webhook implements Node {
  name: String!
  targetUrl: String!
  isActive: Boolean!
  secretKey: String
  # The ID of the object.
  id: ID!
  # List of webhook events.
  events: [WebhookEvent!]!
  serviceAccount: ServiceAccount!
    @deprecated(
      reason: "Use the `app` field instead. This field will be removed after 2020-07-31."
    )
  app: App!
}

type WebhookCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [WebhookCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type WebhookCountableEdge {
  # The item at the end of the edge.
  node: Webhook!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new webhook subscription.
type WebhookCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  webhookErrors: [WebhookError!]!
  webhook: Webhook
}

input WebhookCreateInput {
  # The name of the webhook.
  name: String
  # The url to receive the payload.
  targetUrl: String
  # The events that webhook wants to subscribe. The CHECKOUT_QUANTITY_CHANGED is depreacted. It will be removed in Saleor 3.0
  events: [WebhookEventTypeEnum]
  # DEPRECATED: Use the `app` field instead. This field will be removed after 2020-07-31.
  serviceAccount: ID
  # ID of the app to which webhook belongs.
  app: ID
  # Determine if webhook will be set active or not.
  isActive: Boolean
  # The secret key used to create a hash signature with each payload.
  secretKey: String
}

# Deletes a webhook subscription.
type WebhookDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  webhookErrors: [WebhookError!]!
  webhook: Webhook
}

type WebhookError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: WebhookErrorCode!
}

# An enumeration.
enum WebhookErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

# Webhook event.
type WebhookEvent {
  # Internal name of the event type.
  eventType: WebhookEventTypeEnum!
  # Display name of the event.
  name: String!
}

# An enumeration.
enum WebhookEventTypeEnum {
  ANY_EVENTS
  ORDER_CREATED
  ORDER_FULLY_PAID
  ORDER_UPDATED
  ORDER_CANCELLED
  ORDER_FULFILLED
  INVOICE_REQUESTED
  INVOICE_DELETED
  INVOICE_SENT
  CUSTOMER_CREATED
  PRODUCT_CREATED
  PRODUCT_UPDATED
  CHECKOUT_QUANTITY_CHANGED
  CHECKOUT_CREATED
  CHECKOUT_UPDATED
  FULFILLMENT_CREATED
}

input WebhookFilterInput {
  search: String
  isActive: Boolean
}

# An enumeration.
enum WebhookSampleEventTypeEnum {
  ORDER_CREATED
  ORDER_FULLY_PAID
  ORDER_UPDATED
  ORDER_CANCELLED
  ORDER_FULFILLED
  INVOICE_REQUESTED
  INVOICE_DELETED
  INVOICE_SENT
  CUSTOMER_CREATED
  PRODUCT_CREATED
  PRODUCT_UPDATED
  CHECKOUT_QUANTITY_CHANGED
  CHECKOUT_CREATED
  CHECKOUT_UPDATED
  FULFILLMENT_CREATED
}

enum WebhookSortField {
  # Sort webhooks by name.
  NAME
  # Sort webhooks by service account.
  SERVICE_ACCOUNT
  # Sort webhooks by target url.
  TARGET_URL
  # Sort webhooks by service account.
  APP
}

input WebhookSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort webhooks by the selected field.
  field: WebhookSortField!
}

# Updates a webhook subscription.
type WebhookUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  webhookErrors: [WebhookError!]!
  webhook: Webhook
}

input WebhookUpdateInput {
  # The new name of the webhook.
  name: String
  # The url to receive the payload.
  targetUrl: String
  # The events that webhook wants to subscribe. The CHECKOUT_QUANTITY_CHANGED is depreacted. It will be removed in Saleor 3.0
  events: [WebhookEventTypeEnum]
  # DEPRECATED: Use the `app` field instead. This field will be removed after 2020-07-31.
  serviceAccount: ID
  # ID of the app to which webhook belongs.
  app: ID
  # Determine if webhook will be set active or not.
  isActive: Boolean
  # Use to create a hash signature with each payload.
  secretKey: String
}

# Represents weight value in a specific weight unit.
type Weight {
  # Weight unit.
  unit: WeightUnitsEnum!
  # Weight value.
  value: Float!
}

scalar WeightScalar

# An enumeration.
enum WeightUnitsEnum {
  KG
  LB
  OZ
  G
}

# Wishlist item.
type Wishlist implements Node {
  # The ID of the object.
  id: ID!
  createdAt: DateTime!
  items(
    before: String
    after: String
    first: Int
    last: Int
    id: ID
  ): WishlistItemCountableConnection!
}

# Add product to the current user's wishlist.
type WishlistAddProductMutation {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The wishlist of the current user.
  wishlist: [WishlistItem]
  wishlistErrors: [WishlistError!]!
}

# Add product variant to the current user's wishlist.
type WishlistAddProductVariantMutation {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The wishlist of the current user.
  wishlist: [WishlistItem]
  wishlistErrors: [WishlistError!]!
}

type WishlistError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: WishlistErrorCode!
}

# An enumeration.
enum WishlistErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

# Wishlist item.
type WishlistItem implements Node {
  # The ID of the object.
  id: ID!
  wishlist: Wishlist!
  product: Product!
  variants(
    before: String
    after: String
    first: Int
    last: Int
  ): ProductVariantCountableConnection!
}

type WishlistItemCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [WishlistItemCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type WishlistItemCountableEdge {
  # The item at the end of the edge.
  node: WishlistItem!
  # A cursor for use in pagination.
  cursor: String!
}

# Remove product from the current user's wishlist.
type WishlistRemoveProductMutation {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The wishlist of the current user.
  wishlist: [WishlistItem]
  wishlistErrors: [WishlistError!]!
}

# Remove product variant from the current user's wishlist.
type WishlistRemoveProductVariantMutation {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. This field will be removed after 2020-07-31."
    )
  # The wishlist of the current user.
  wishlist: [WishlistItem]
  wishlistErrors: [WishlistError!]!
}

